<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Programación Orientada a Objetos | oscarzt20</title>
<meta name="keywords" content="programacion, enciclopedia, post">
<meta name="description" content="
I. Introducción a la Programación Orientada a Objetos (POO)
La programación orientada a objetos es un paradigma que organiza el código en objetos, cada uno con sus propios datos (atributos) y comportamientos (métodos), evitando que otros objetos tengan acceso a estos elementos de manera no controlada.
Los beneficios y objetivos de POO son:

Natural: Permite construir un sistema que modele elementos del mundo real.
Confiable: Un programa bien diseñado y codificado va a funcionar como es esperado sin importar el tamaño, y el testing se vuelve más sencillo.
Reusable: Una vez un problema es resuelto se puede volver a usar la solución.
Fácil de mantener: Se estima que del 60%-80% del trabajo en un programa es el mantenimiento, el 20% es el desarrollo. Un bug se puede resolver corrigiendo una sola parte.
Extendible: Un software creado en POO puede crecer y cambiar sin muchas dificultades.
Oportuno: Varias partes del programa se pueden desarrollar en paralelo. Es esencial realizar correctamente el análisis y diseño.

1.1 Diferencias entre POO y la programación estructurada
A diferencia de la programación estructurada, donde el código se escribe en funciones que resuelven un problema lógico y este se ejecuta en orden de arriba hacia abajo, la POO organiza el código en un sistema conectado basado en objetos, y el orden en que se escriben las partes de una clase no afecta su funcionamiento.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/apuntes/programaci%C3%B3n-orientada-a-objetos/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.91fc30a618dc2be3b50779f120709c7628638d8d4bb6569aa827f35db262aaa2.css" integrity="sha256-kfwwphjcK&#43;O1B3nxIHCcdihjjY1LtlaaqCfzXbJiqqI=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/apuntes/programaci%C3%B3n-orientada-a-objetos/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="oscarzt20 (Alt + H)">oscarzt20</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/proyectos/" title="Portafolio">
                    <span>Portafolio</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/recursos/" title="Recursos / Guías">
                    <span>Recursos / Guías</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/apuntes/" title="Estudios">
                    <span>Estudios</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/pasatiempos/" title="Entretenimiento">
                    <span>Entretenimiento</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/recetas/" title="Recetas">
                    <span>Recetas</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/apuntes/">Apuntes</a></div>
    <h1 class="post-title entry-hint-parent">
      Programación Orientada a Objetos
    </h1>
    <div class="post-meta">

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#i-introducci%c3%b3n-a-la-programaci%c3%b3n-orientada-a-objetos-poo" aria-label="I. Introducción a la Programación Orientada a Objetos (POO)">I. Introducción a la Programación Orientada a Objetos (POO)</a><ul>
                        
                <li>
                    <a href="#11-diferencias-entre-poo-y-la-programaci%c3%b3n-estructurada" aria-label="1.1 Diferencias entre POO y la programación estructurada">1.1 Diferencias entre POO y la programación estructurada</a></li>
                <li>
                    <a href="#12-los-4-pilares-de-poo" aria-label="1.2 Los 4 pilares de POO">1.2 Los 4 pilares de POO</a></li></ul>
                </li>
                <li>
                    <a href="#ii-conceptos-b%c3%a1sicos-de-poo" aria-label="II. Conceptos básicos de POO">II. Conceptos básicos de POO</a><ul>
                        
                <li>
                    <a href="#21-objetos" aria-label="2.1 Objetos">2.1 Objetos</a><ul>
                        
                <li>
                    <a href="#caracter%c3%adsticas-de-los-objetos" aria-label="Características de los objetos">Características de los objetos</a><ul>
                        
                <li>
                    <a href="#atributos" aria-label="Atributos">Atributos</a></li>
                <li>
                    <a href="#m%c3%a9todos" aria-label="Métodos">Métodos</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#22-clases" aria-label="2.2 Clases">2.2 Clases</a><ul>
                        
                <li>
                    <a href="#elementos-en-una-clase" aria-label="Elementos en una clase">Elementos en una clase</a></li>
                <li>
                    <a href="#relaciones-entre-clases" aria-label="Relaciones entre clases">Relaciones entre clases</a><ul>
                        
                <li>
                    <a href="#dependencia---usa" aria-label="Dependencia - &ldquo;usa&rdquo;">Dependencia - &ldquo;usa&rdquo;</a></li>
                <li>
                    <a href="#asociaci%c3%b3n---conoce-a-o-trabaja-con" aria-label="Asociación - &ldquo;conoce a&rdquo; o &ldquo;trabaja con&rdquo;">Asociación - &ldquo;conoce a&rdquo; o &ldquo;trabaja con&rdquo;</a></li>
                <li>
                    <a href="#agregaci%c3%b3n---tiene-un-existe-por-separado" aria-label="Agregación - &ldquo;tiene un&rdquo; (Existe por separado)">Agregación - &ldquo;tiene un&rdquo; (Existe por separado)</a></li>
                <li>
                    <a href="#composici%c3%b3n---tiene-un-no-existe-por-separado" aria-label="Composición - &ldquo;tiene un&rdquo; (No existe por separado)">Composición - &ldquo;tiene un&rdquo; (No existe por separado)</a></li>
                <li>
                    <a href="#herencia---es-un" aria-label="Herencia - &ldquo;es un&rdquo;">Herencia - &ldquo;es un&rdquo;</a></li></ul>
                </li>
                <li>
                    <a href="#tipos-de-clases" aria-label="Tipos de clases">Tipos de clases</a><ul>
                        
                <li>
                    <a href="#clase-concreta" aria-label="Clase concreta">Clase concreta</a></li>
                <li>
                    <a href="#clase-abstracta" aria-label="Clase abstracta">Clase abstracta</a></li>
                <li>
                    <a href="#clase-est%c3%a1tica" aria-label="Clase estática">Clase estática</a></li>
                <li>
                    <a href="#clase-sellada" aria-label="Clase sellada">Clase sellada</a></li>
                <li>
                    <a href="#interfaz" aria-label="Interfaz">Interfaz</a></li>
                <li>
                    <a href="#clase-parcial" aria-label="Clase parcial">Clase parcial</a></li>
                <li>
                    <a href="#clase-gen%c3%a9rica" aria-label="Clase genérica">Clase genérica</a></li></ul>
                </li>
                <li>
                    <a href="#cardinalidad" aria-label="Cardinalidad">Cardinalidad</a></li></ul>
                </li>
                <li>
                    <a href="#23-tipos-de-datos-no-primitivos" aria-label="2.3 Tipos de datos no primitivos">2.3 Tipos de datos no primitivos</a></li>
                <li>
                    <a href="#24-documentaci%c3%b3n-y-buenas-pr%c3%a1cticas" aria-label="2.4 Documentación y buenas prácticas">2.4 Documentación y buenas prácticas</a><ul>
                        
                <li>
                    <a href="#recomendaciones" aria-label="Recomendaciones">Recomendaciones</a></li>
                <li>
                    <a href="#documentaci%c3%b3n-del-c%c3%b3digo" aria-label="Documentación del código">Documentación del código</a></li>
                <li>
                    <a href="#diagrama-de-clases" aria-label="Diagrama de clases">Diagrama de clases</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#iii-ciclo-de-vida-de-un-objeto" aria-label="III. Ciclo de vida de un objeto">III. Ciclo de vida de un objeto</a><ul>
                        
                <li>
                    <a href="#31-creaci%c3%b3n-del-objeto" aria-label="3.1 Creación del objeto">3.1 Creación del objeto</a><ul>
                        
                <li>
                    <a href="#constructores" aria-label="Constructores">Constructores</a></li>
                <li>
                    <a href="#instanciaci%c3%b3n" aria-label="Instanciación">Instanciación</a><ul>
                        
                <li>
                    <a href="#operadores-de-instanciaci%c3%b3n" aria-label="Operadores de instanciación">Operadores de instanciación</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#33-uso-del-objeto" aria-label="3.3 Uso del objeto">3.3 Uso del objeto</a><ul>
                        
                <li>
                    <a href="#acceso-a-atributos-y-m%c3%a9todos" aria-label="Acceso a atributos y métodos">Acceso a atributos y métodos</a></li></ul>
                </li>
                <li>
                    <a href="#34-alcance-y-duraci%c3%b3n-del-objeto" aria-label="3.4 Alcance y duración del objeto">3.4 Alcance y duración del objeto</a><ul>
                        
                <li>
                    <a href="#variables-de-instancia-y-variables-locales" aria-label="Variables de instancia y variables locales">Variables de instancia y variables locales</a></li></ul>
                </li>
                <li>
                    <a href="#35-destrucci%c3%b3n-y-gesti%c3%b3n-de-memoria" aria-label="3.5 Destrucción y gestión de memoria">3.5 Destrucción y gestión de memoria</a><ul>
                        
                <li>
                    <a href="#destructores" aria-label="Destructores">Destructores</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#iv-mecanismos-de-poo" aria-label="IV. Mecanismos de POO">IV. Mecanismos de POO</a><ul>
                        
                <li>
                    <a href="#41-encapsulaci%c3%b3n-y-acceso" aria-label="4.1 Encapsulación y acceso">4.1 Encapsulación y acceso</a><ul>
                        
                <li>
                    <a href="#modificadores-de-acceso" aria-label="Modificadores de acceso">Modificadores de acceso</a></li>
                <li>
                    <a href="#accessors" aria-label="Accessors">Accessors</a><ul>
                        
                <li>
                    <a href="#funciones-de-interfaz" aria-label="Funciones de interfaz">Funciones de interfaz</a></li>
                <li>
                    <a href="#propiedades" aria-label="Propiedades">Propiedades</a></li></ul>
                </li>
                <li>
                    <a href="#mutators" aria-label="Mutators">Mutators</a></li>
                <li>
                    <a href="#%c3%a1mbito-o-scope" aria-label="Ámbito o scope">Ámbito o scope</a><ul>
                        
                <li>
                    <a href="#this" aria-label="This">This</a></li>
                <li>
                    <a href="#static" aria-label="Static">Static</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#42-abstracci%c3%b3n-e-interfaces-propias" aria-label="4.2 Abstracción e interfaces propias">4.2 Abstracción e interfaces propias</a><ul>
                        
                <li>
                    <a href="#interfaz-propia" aria-label="Interfaz propia">Interfaz propia</a><ul>
                        
                <li>
                    <a href="#implementaci%c3%b3n" aria-label="Implementación">Implementación</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#43-herencia-y-especializaci%c3%b3n" aria-label="4.3 Herencia y especialización">4.3 Herencia y especialización</a><ul>
                        
                <li>
                    <a href="#jerarqu%c3%ada-de-clases" aria-label="Jerarquía de clases">Jerarquía de clases</a></li></ul>
                </li>
                <li>
                    <a href="#44-polimorfismo-din%c3%a1mico-y-est%c3%a1tico" aria-label="4.4 Polimorfismo dinámico y estático">4.4 Polimorfismo dinámico y estático</a><ul>
                        
                <li>
                    <a href="#sobreescritura-overriding" aria-label="Sobreescritura (Overriding)">Sobreescritura (Overriding)</a></li>
                <li>
                    <a href="#sobrecarga-overloading" aria-label="Sobrecarga (Overloading)">Sobrecarga (Overloading)</a><ul>
                        
                <li>
                    <a href="#sobrecarga-de-m%c3%a9todos" aria-label="Sobrecarga de métodos">Sobrecarga de métodos</a></li>
                <li>
                    <a href="#sobrecarga-de-constructores" aria-label="Sobrecarga de constructores">Sobrecarga de constructores</a></li>
                <li>
                    <a href="#sobrecarga-de-operadores" aria-label="Sobrecarga de operadores">Sobrecarga de operadores</a><ul>
                        
                <li>
                    <a href="#sobrecarga-de-operadores-aritm%c3%a9ticos" aria-label="Sobrecarga de operadores aritméticos">Sobrecarga de operadores aritméticos</a></li>
                <li>
                    <a href="#sobrecarga-de-operadores-de-comparaci%c3%b3n" aria-label="Sobrecarga de operadores de comparación">Sobrecarga de operadores de comparación</a></li>
                <li>
                    <a href="#sobrecarga-de-operadores-de-incrementodecremento" aria-label="Sobrecarga de operadores de incremento/decremento">Sobrecarga de operadores de incremento/decremento</a></li>
                <li>
                    <a href="#sobrecarga-de-operadores-de-conversi%c3%b3n" aria-label="Sobrecarga de operadores de conversión">Sobrecarga de operadores de conversión</a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#45-composici%c3%b3n" aria-label="4.5 Composición">4.5 Composición</a><ul>
                        
                <li>
                    <a href="#decoraci%c3%b3n" aria-label="Decoración">Decoración</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#v-estructuras-de-datos-abstractos" aria-label="V. Estructuras de datos abstractos">V. Estructuras de datos abstractos</a><ul>
                        
                <li>
                    <a href="#51-estructuras-de-datos-lineales" aria-label="5.1 Estructuras de datos lineales">5.1 Estructuras de datos lineales</a><ul>
                        
                <li>
                    <a href="#arreglo-array" aria-label="Arreglo (Array)">Arreglo (Array)</a><ul>
                        
                <li>
                    <a href="#referenciar-objetos" aria-label="Referenciar objetos">Referenciar objetos</a></li>
                <li>
                    <a href="#indexer" aria-label="Indexer">Indexer</a></li></ul>
                </li>
                <li>
                    <a href="#lista-ligada-linked-list" aria-label="Lista Ligada (Linked List)">Lista Ligada (Linked List)</a></li>
                <li>
                    <a href="#pila-stack" aria-label="Pila (Stack)">Pila (Stack)</a></li>
                <li>
                    <a href="#cola-queue" aria-label="Cola (Queue)">Cola (Queue)</a></li>
                <li>
                    <a href="#hash-tables-diccionarios-maps" aria-label="Hash tables (Diccionarios, Maps)">Hash tables (Diccionarios, Maps)</a></li></ul>
                </li>
                <li>
                    <a href="#52-estructura-de-datos-no-lineales" aria-label="5.2 Estructura de datos no lineales">5.2 Estructura de datos no lineales</a><ul>
                        
                <li>
                    <a href="#%c3%a1rbol-tree" aria-label="Árbol (Tree)">Árbol (Tree)</a></li>
                <li>
                    <a href="#grafo" aria-label="Grafo">Grafo</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#vi-manejo-de-datos-en-poo" aria-label="VI. Manejo de datos en POO">VI. Manejo de datos en POO</a><ul>
                        
                <li>
                    <a href="#persistencia" aria-label="Persistencia">Persistencia</a></li>
                <li>
                    <a href="#serializaci%c3%b3n-binaria-poo" aria-label="Serialización Binaria (POO)">Serialización Binaria (POO)</a></li>
                <li>
                    <a href="#serializaci%c3%b3n-con-xml-programaci%c3%b3n-estructurada" aria-label="Serialización con XML (Programación estructurada)">Serialización con XML (Programación estructurada)</a><ul>
                        
                <li>
                    <a href="#serializaci%c3%b3n-normal-con-xml" aria-label="Serialización normal con XML">Serialización normal con XML</a></li>
                <li>
                    <a href="#serializaci%c3%b3n-por-composici%c3%b3n-con-xml" aria-label="Serialización por composición con XML">Serialización por composición con XML</a></li></ul>
                </li>
                <li>
                    <a href="#deserializaci%c3%b3n" aria-label="Deserialización">Deserialización</a></li></ul>
                </li>
                <li>
                    <a href="#vii-patrones-de-dise%c3%b1o-en-poo" aria-label="VII. Patrones de diseño en POO">VII. Patrones de diseño en POO</a><ul>
                        
                <li>
                    <a href="#71-patrones-de-creaci%c3%b3n" aria-label="7.1 Patrones de creación">7.1 Patrones de creación</a></li>
                <li>
                    <a href="#72-patrones-de-estructura" aria-label="7.2 Patrones de estructura">7.2 Patrones de estructura</a></li>
                <li>
                    <a href="#73-patrones-de-comportamiento" aria-label="7.3 Patrones de comportamiento">7.3 Patrones de comportamiento</a></li>
                <li>
                    <a href="#74-anti-patrones" aria-label="7.4 Anti-patrones">7.4 Anti-patrones</a></li></ul>
                </li>
                <li>
                    <a href="#viii-poo-y-la-programaci%c3%b3n-orientada-a-eventos" aria-label="VIII. POO y la programación orientada a eventos">VIII. POO y la programación orientada a eventos</a><ul>
                        
                <li>
                    <a href="#81-interfaces-gr%c3%a1ficas-y-eventos" aria-label="8.1 Interfaces gráficas y eventos">8.1 Interfaces gráficas y eventos</a><ul>
                        
                <li>
                    <a href="#eventos" aria-label="Eventos">Eventos</a></li>
                <li>
                    <a href="#delegados" aria-label="Delegados">Delegados</a></li>
                <li>
                    <a href="#handlers" aria-label="Handlers">Handlers</a></li>
                <li>
                    <a href="#sinks" aria-label="Sinks">Sinks</a></li></ul>
                </li>
                <li>
                    <a href="#82-excepciones-y-manejo-de-errores" aria-label="8.2 Excepciones y manejo de errores">8.2 Excepciones y manejo de errores</a></li></ul>
                </li>
                <li>
                    <a href="#-m%c3%a1s-informaci%c3%b3n" aria-label="/ Más Información">/ Más Información</a><ul>
                        
                <li>
                    <a href="#lenguajes-de-programaci%c3%b3n" aria-label="Lenguajes de programación">Lenguajes de programación</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><hr>
<h2 id="i-introducción-a-la-programación-orientada-a-objetos-poo">I. Introducción a la Programación Orientada a Objetos (POO)<a hidden class="anchor" aria-hidden="true" href="#i-introducción-a-la-programación-orientada-a-objetos-poo">#</a></h2>
<p>La programación orientada a objetos es un paradigma que organiza el código en objetos, cada uno con sus propios datos (<em>atributos</em>) y comportamientos (<em>métodos</em>), evitando que otros objetos tengan acceso a estos elementos de manera no controlada.</p>
<p>Los beneficios y objetivos de POO son:</p>
<ul>
<li><strong>Natural</strong>: Permite construir un sistema que modele elementos del mundo real.</li>
<li><strong>Confiable</strong>: Un programa bien diseñado y codificado va a funcionar como es esperado sin importar el tamaño, y el testing se vuelve más sencillo.</li>
<li><strong>Reusable</strong>: Una vez un problema es resuelto se puede volver a usar la solución.</li>
<li><strong>Fácil de mantener</strong>: Se estima que del 60%-80% del trabajo en un programa es el mantenimiento, el 20% es el desarrollo. Un bug se puede resolver corrigiendo una sola parte.</li>
<li><strong>Extendible</strong>: Un software creado en POO puede crecer y cambiar sin muchas dificultades.</li>
<li><strong>Oportuno</strong>: Varias partes del programa se pueden desarrollar en paralelo. Es esencial realizar correctamente el análisis y diseño.</li>
</ul>
<h3 id="11-diferencias-entre-poo-y-la-programación-estructurada">1.1 Diferencias entre POO y la programación estructurada<a hidden class="anchor" aria-hidden="true" href="#11-diferencias-entre-poo-y-la-programación-estructurada">#</a></h3>
<p>A diferencia de la programación estructurada, donde el código se escribe en <em>funciones</em> que resuelven un problema lógico y este se ejecuta en orden de arriba hacia abajo, la POO organiza el código en un sistema conectado basado en <em>objetos</em>, y el orden en que se escriben las partes de una clase no afecta su funcionamiento.</p>
<p>Algunos lenguajes como Python o JavaScript no usan archivos de clase como Java o C#, pero siguen permitiendo la programación orientada a objetos. En su lugar, organizan el código en módulos, lo que ayuda a manejar proyectos grandes de manera más ordenada.</p>
<h3 id="12-los-4-pilares-de-poo">1.2 Los 4 pilares de POO<a hidden class="anchor" aria-hidden="true" href="#12-los-4-pilares-de-poo">#</a></h3>
<ul>
<li><strong>Encapsulación</strong>: Es la combinación de atributos y métodos en una sola entidad (objeto), el cual solo debe permitir el acceso a sus datos y comportamiento a otros objetos con los que va a interactuar.</li>
<li><strong>Abstracción</strong>: Permite mostrar solo los elementos esenciales de un objeto al usuario final, ocultando los detalles internos de su implementación.</li>
<li><strong>Herencia</strong>: Permite que una clase aproveche los atributos y métodos de una ya existente sin tener que repetir el código, sino únicamente adicionando lo que le falte.</li>
<li><strong>Polimorfismo</strong>: Es la capacidad que tiene un método para comportarse de distintas maneras según el objeto que lo esté usando.</li>
<li><strong>(+) Composición</strong>: Aunque no es un principio oficial de POO la composición es un concepto importante que asimila que un objeto está formado por otros objetos, estableciendo una relación de dependencia entre ellos.</li>
</ul>
<h2 id="ii-conceptos-básicos-de-poo">II. Conceptos básicos de POO<a hidden class="anchor" aria-hidden="true" href="#ii-conceptos-básicos-de-poo">#</a></h2>
<h3 id="21-objetos">2.1 Objetos<a hidden class="anchor" aria-hidden="true" href="#21-objetos">#</a></h3>
<p>Son elementos que componen un sistema. Este contiene datos y comportamientos.</p>
<p><strong>Ejemplo</strong></p>
<p>En un automóvil las distintas partes que lo conforman son <em>objetos</em>, los cuales se pueden comunicar entre sí para funcionar.</p>
<h4 id="características-de-los-objetos">Características de los objetos<a hidden class="anchor" aria-hidden="true" href="#características-de-los-objetos">#</a></h4>
<h5 id="atributos">Atributos<a hidden class="anchor" aria-hidden="true" href="#atributos">#</a></h5>
<p>Los atributos representan las propiedades de un objeto y almacenan su información en un momento dado. Estos definen el <em>estado</em> del objeto y pueden cambiar durante la ejecución del programa.</p>
<p><strong>Elementos de un atributo</strong></p>
<ul>
<li><strong>Un nombre</strong>, que lo identifica dentro de la clase.</li>
<li><strong>Un tipo de dato</strong>, que determina qué valores puede almacenar.</li>
<li><strong>Un nivel de acceso</strong>, que controla cómo se puede modificar o leer.</li>
</ul>
<p><strong>Ejemplo en C#</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Persona</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Atributos de la clase Persona (nivel de acceso, tipo de dato y nombre)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">string</span> nombre;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> edad;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="métodos">Métodos<a hidden class="anchor" aria-hidden="true" href="#métodos">#</a></h5>
<p>Representan lo que el objeto puede hacer.</p>
<p>La diferencia entre un método y una función es que los <em>métodos</em> son parte de los objetos y pueden acceder a sus datos, mientras que las <em>funciones</em> solo trabajan con los valores que se les pasan como parámetros.</p>
<p><strong>Elementos de un método</strong></p>
<ul>
<li><strong>Nombre</strong>: Identifica al método dentro de la clase.</li>
<li><strong>Parámetros</strong>: Valores de entrada que el método puede recibir para procesar (puede no tener parámetros).</li>
<li><strong>Tipo de retorno</strong>: El tipo de dato que el método devuelve al terminar su ejecución. Puede ser un tipo de dato (<code>int</code>, <code>string</code>, <code>bool</code>, etc.) o <code>void</code> si no devuelve nada.</li>
<li><strong>Cuerpo</strong>: Conjunto de instrucciones o código que define qué hace el método.</li>
<li><strong>Modificadores de acceso</strong>: Palabras clave que controlan el acceso (public, private) o comportamiento especial (static, virtual, etc.) del método.</li>
</ul>
<p><strong>Los métodos se pueden activar/invocar al</strong>:</p>
<ul>
<li><strong>Recibir un mensaje</strong>: Se invocó el método desde otro objeto</li>
<li><strong>Con un cambio de estado</strong>: Un atributo cambió en el objeto.</li>
</ul>
<p><strong>Para que el método sea invocado, se requiere conocer</strong>:</p>
<ul>
<li><strong>Nombre</strong> del método.</li>
<li><strong>Parámetros</strong> a pasar al método (Si es que el método los acepta).</li>
<li><strong>Tipo de dato</strong> que va a retornar el método.</li>
</ul>
<p><strong>Ejemplo en C#</strong></p>
<p>La clase <code>Persona</code> se define con dos atributos (<code>nombre</code> y <code>edad</code>) y un método <code>MostrarInfo()</code> que imprime esos datos. En <code>Main</code>, se crea una instancia basada en <code>Persona</code>, se le asignan valores y se llama al método para mostrar la información.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Persona</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Declaración de variables</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> nombre;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> edad;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Método para mostrar información de la persona</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> MostrarInfo()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Console.WriteLine(<span style="color:#e6db74">$&#34;Nombre: {nombre}, Edad: {edad}&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Creación de un objeto Persona y asignación de valores</span>
</span></span><span style="display:flex;"><span>        Persona persona1 = <span style="color:#66d9ef">new</span> Persona();
</span></span><span style="display:flex;"><span>        persona1.nombre = <span style="color:#e6db74">&#34;Juan&#34;</span>;
</span></span><span style="display:flex;"><span>        persona1.edad = <span style="color:#ae81ff">25</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Llamada al método MostrarInfo()</span>
</span></span><span style="display:flex;"><span>        persona1.MostrarInfo(); <span style="color:#75715e">// Salida: Nombre: Juan, Edad: 25</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="22-clases">2.2 Clases<a hidden class="anchor" aria-hidden="true" href="#22-clases">#</a></h3>
<p>Una clase es el plano a partir del cual se determinan los atributos y métodos que contendrá un objeto. Esto permite reutilizar código para crear múltiples instancias del mismo objeto.</p>
<p><strong>Ejemplo</strong></p>
<p>Una empresa que tiene varios empleados. Cada empleado es un <em>objeto</em>, pero todos se crean a partir de una misma <em>clase</em> llamada <code>Empleado</code>.</p>
<h4 id="elementos-en-una-clase">Elementos en una clase<a hidden class="anchor" aria-hidden="true" href="#elementos-en-una-clase">#</a></h4>
<p>En una clase, el orden de los elementos presentes debe ser:</p>
<ol>
<li><strong>Nombre de la clase</strong></li>
<li><strong>Atributos</strong></li>
<li><strong>Constructores</strong></li>
<li><strong>Funciones de interfaz (Getters y Setters)</strong></li>
<li><strong>Demás métodos</strong></li>
</ol>
<h4 id="relaciones-entre-clases">Relaciones entre clases<a hidden class="anchor" aria-hidden="true" href="#relaciones-entre-clases">#</a></h4>
<p>En sistemas POO las clases no suelen trabajar de forma aislada, sino que estas se relacionan entre sí de diversas maneras para representar interacciones, dependencias y jerarquías. Estas relaciones ayudan a estructurar el código de forma más clara, reutilizable y mantenible.</p>
<p>Se entiende que una clase puede ser &ldquo;propietaria&rdquo; de otra cuando es responsable de su creación, gestión y eliminación. Además, algunas relaciones se consideran más &ldquo;fuertes&rdquo;, ya que implican una mayor relación, mientras que otras son más &ldquo;débiles&rdquo;, porque solo llevan a cabo una interacción temporal.</p>
<h5 id="dependencia---usa">Dependencia - &ldquo;usa&rdquo;<a hidden class="anchor" aria-hidden="true" href="#dependencia---usa">#</a></h5>
<p>Una clase depende de otra cuando utiliza temporalmente sus datos o comportamiento para cumplir una operación. La clase dependiente no necesita almacenar una referencia al objeto, solo usarlo mientras dura el método.</p>
<p>Se usa cuando una clase necesita ayuda de otra para ejecutar una acción puntual.</p>
<p><strong>Ejemplo en C#:</strong></p>
<p>Una <code>Impresora</code> <em>usa</em> un <code>Documento</code> para imprimir su contenido.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Documento</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Contenido { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Clase dependiente</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Impresora</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Imprimir(Documento doc)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Console.WriteLine(<span style="color:#e6db74">&#34;Imprimiendo: &#34;</span> + doc.Contenido);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="asociación---conoce-a-o-trabaja-con">Asociación - &ldquo;conoce a&rdquo; o &ldquo;trabaja con&rdquo;<a hidden class="anchor" aria-hidden="true" href="#asociación---conoce-a-o-trabaja-con">#</a></h5>
<p>Una clase puede estar relacionada a otra mediante la referencia de uno de sus atributos. Sin embargo, esto no implica que una controle a la otra. Esta relación puede ser unidireccional o bidireccional.</p>
<p>Suele usarse cuando dos clases colaboran entre sí pero sin depender mutuamente una de la otra.</p>
<p><strong>Ejemplo en C#</strong></p>
<p>El <code>Profesor</code> <em>conoce a</em> un <code>Estudiante</code>, es decir, solo lo tiene de referencia.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Estudiante</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Nombre { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Profesor</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Estudiante Alumno { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }  <span style="color:#75715e">// Asociación: conoce a Estudiante</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="agregación---tiene-un-existe-por-separado">Agregación - &ldquo;tiene un&rdquo; (Existe por separado)<a hidden class="anchor" aria-hidden="true" href="#agregación---tiene-un-existe-por-separado">#</a></h5>
<p>Una clase puede contener objetos de otra clase, pero esos objetos pueden vivir por sí mismos fuera del contenedor.</p>
<p>Se puede usar para representar componentes que son parte de otros, pero que a su vez pueden existir de manera independiente.</p>
<p><strong>Ejemplo en C#</strong></p>
<p>Una <code>Universidad</code> <em>tiene</em> <code>Carrera</code>(s) pero podrían existir fuera de ella también, como en otra universidad diferente.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Carrera</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Nombre { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Universidad</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> List&lt;Carrera&gt; Carreras { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; } = <span style="color:#66d9ef">new</span> List&lt;Carrera&gt;();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="composición---tiene-un-no-existe-por-separado">Composición - &ldquo;tiene un&rdquo; (No existe por separado)<a hidden class="anchor" aria-hidden="true" href="#composición---tiene-un-no-existe-por-separado">#</a></h5>
<p>Una clase puede poseer objetos de otras clases, pero a diferencia de la agregación, estos no pueden existir independientemente, ya que si la clase contenedora desaparece, los objetos controlados también desaparecen.</p>
<p>Se suele usar cuando un objeto forma parte inseparable de otro y no tiene sentido que exista por si solo.</p>
<p><strong>Ejemplo en C#</strong></p>
<p>Una <code>Casa</code> <em>tiene</em> <code>Habitacion</code>(es), y estas solo pueden ser creadas y gestionadas por la misma <code>Casa</code>, por lo que no podrían estar fuera de ella.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Habitacion</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Numero { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Casa</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> List&lt;Habitacion&gt; habitaciones = <span style="color:#66d9ef">new</span> List&lt;Habitacion&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Casa()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        habitaciones.Add(<span style="color:#66d9ef">new</span> Habitacion { Numero = <span style="color:#ae81ff">1</span> });
</span></span><span style="display:flex;"><span>        habitaciones.Add(<span style="color:#66d9ef">new</span> Habitacion { Numero = <span style="color:#ae81ff">2</span> });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="herencia---es-un">Herencia - &ldquo;es un&rdquo;<a hidden class="anchor" aria-hidden="true" href="#herencia---es-un">#</a></h5>
<p>Las clases pueden tener una relación jerárquica, donde una clase hereda los atributos y comportamientos de otra (Clase base y clase hija) con el fin de crear una clase más especializada.</p>
<p>Se usa la herencia cuando una clase comparte funcionalidad con otra pero también necesita comportamientos propios.</p>
<p><strong>Ejemplo en C#</strong></p>
<p><code>Perro</code> <em>es un</em> <code>Animal</code> ya que hereda esa descripción y comportamientos, pero también añade los comportamientos propios de esa especie, como ladrar.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Animal</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Comer()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Console.WriteLine(<span style="color:#e6db74">&#34;El animal está comiendo.&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Perro</span> : Animal
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Ladrar()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Console.WriteLine(<span style="color:#e6db74">&#34;Guau!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="tipos-de-clases">Tipos de clases<a hidden class="anchor" aria-hidden="true" href="#tipos-de-clases">#</a></h4>
<p>Así como existen diferentes formas en las que se relacionan las clases, también existen distintos tipos de clases según su propósito, restricciones y forma de implementación. Estos tipos permiten organizar el código de forma más clara, flexible y segura.</p>
<h5 id="clase-concreta">Clase concreta<a hidden class="anchor" aria-hidden="true" href="#clase-concreta">#</a></h5>
<p>Es la clase tradicional que se puede instanciar directamente. Contiene la implementación completa de todos sus métodos y puede heredar o ser heredada.</p>
<p>Se usa para crear objetos funcionales que representen entidades del sistema.</p>
<p><strong>Ejemplo en C#</strong></p>
<p><code>Persona</code> es una clase funcional que se puede usar normalmente.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Persona</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Nombre { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Saludar()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Console.WriteLine(<span style="color:#e6db74">$&#34;Hola, soy {Nombre}&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="clase-abstracta">Clase abstracta<a hidden class="anchor" aria-hidden="true" href="#clase-abstracta">#</a></h5>
<p>Una clase abstracta no puede ser instanciada directamente. Sirve como clase base para otras clases. Puede contener métodos abstractos (sin implementación) que deben ser definidos por las clases hijas, así como métodos normales.</p>
<p>Se usa para definir una estructura base común que otras clases deben completar y especializar.</p>
<p><strong>Ejemplo en C#</strong></p>
<p><code>Animal</code> define lo general, <code>Perro</code> completa lo específico.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Animal</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">void</span> HacerSonido();  <span style="color:#75715e">// Método obligatorio sin implementar</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Dormir() =&gt; Console.WriteLine(<span style="color:#e6db74">&#34;Zzz...&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Perro</span> : Animal
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> HacerSonido()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Console.WriteLine(<span style="color:#e6db74">&#34;Guau!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="clase-estática">Clase estática<a hidden class="anchor" aria-hidden="true" href="#clase-estática">#</a></h5>
<p>Una clase estática no puede ser instanciada ni heredada. Todos sus miembros también deben ser <code>static</code>. Es decir, no trabaja con datos de objetos, sino que ofrece funciones o utilidades que se pueden usar directamente desde la clase.</p>
<p>Se utiliza para agrupar métodos que no necesitan mantener estado, como funciones matemáticas, validaciones, conversiones, u otras herramientas.</p>
<p><strong>Ejemplo en C#</strong></p>
<p>La clase <code>Calculadora</code> contiene métodos que se pueden usar sin necesidad de crear una instancia.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Calculadora</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> Sumar(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) =&gt; a + b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Posible implementación en otra parte del programa</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> resultado = Calculadora.Sumar(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>); <span style="color:#75715e">// Salida: 8</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Implementación incorrecta</span>
</span></span><span style="display:flex;"><span>Calculadora calc = <span style="color:#66d9ef">new</span> Calculadora();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> resultado = calc.Sumar(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>);
</span></span></code></pre></div><h5 id="clase-sellada">Clase sellada<a hidden class="anchor" aria-hidden="true" href="#clase-sellada">#</a></h5>
<p>Una clase sellada no puede ser heredada. Esto impide que otras clases modifiquen o extiendan su comportamiento. También puede mejorar el rendimiento del sistema en tiempo de ejecución.</p>
<p>Se usa cuando se quiere proteger una clase para que nadie más la extienda o modifique, especialmente en bibliotecas, servicios, o clases críticas.</p>
<p><strong>Ejemplo en C#</strong></p>
<p><code>Logger</code> registra los eventos en una aplicación. No queremos que alguien herede de ella y cambie la forma en que se registran los mensajes, como su formato, por lo que se crea como clase sellada.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">sealed</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Logger</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> LogInfo(<span style="color:#66d9ef">string</span> mensaje)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Console.WriteLine(<span style="color:#e6db74">$&#34;[INFO] {mensaje}&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> LogError(<span style="color:#66d9ef">string</span> mensaje)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Console.WriteLine(<span style="color:#e6db74">$&#34;[ERROR] {mensaje}&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="interfaz">Interfaz<a hidden class="anchor" aria-hidden="true" href="#interfaz">#</a></h5>
<p>Una interfaz garantiza que cualquier clase que la implemente tendrá cierto comportamiento, sin importar cómo lo haga, lo cual se define mediante un conjunto de métodos y propiedades sin implementación. Las clases que implementan la interfaz están obligadas a proporcionar su propia versión de esos miembros.</p>
<p>Se usa para definir contratos que distintas clases pueden implementar de manera diferente.</p>
<p><strong>Ejemplo en C#</strong></p>
<p><code>Auto : IVehiculo</code> se compromete a implementar el comportamiento definido por la interfaz <code>IVehiculo</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IVehiculo</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> Encender();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Auto</span> : IVehiculo
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Encender()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Console.WriteLine(<span style="color:#e6db74">&#34;Auto encendido.&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="clase-parcial">Clase parcial<a hidden class="anchor" aria-hidden="true" href="#clase-parcial">#</a></h5>
<p>Una clase parcial se puede dividir en varios archivos del mismo proyecto. Todos los fragmentos se unen en tiempo de compilación como si fuera una sola clase.</p>
<p>Se utiliza para organizar mejor el código, especialmente en proyectos grandes o con código generado automáticamente (como en Windows Forms), y el programador añade lógica personalizada en otro archivo.</p>
<p><strong>Ejemplo C#</strong></p>
<p>El compilador trata como una sola clase a los siguientes archivos:</p>
<p>Archivo <code>Persona.cs</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">partial</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Persona</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Nombre { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Archivo <code>Persona.Saludo.cs</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">partial</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Persona</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Saludar() =&gt; Console.WriteLine(<span style="color:#e6db74">$&#34;Hola, soy {Nombre}&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="clase-genérica">Clase genérica<a hidden class="anchor" aria-hidden="true" href="#clase-genérica">#</a></h5>
<p>Una clase <strong>genérica</strong> permite trabajar con distintos tipos de datos sin duplicar código. Se define con un parámetro de tipo <code>&lt;T&gt;</code>, el cual se especifica al momento de crear una instancia.</p>
<p>Se suele utilizar para colecciones, contenedores, utilidades y estructuras reutilizables.</p>
<p><strong>Ejemplo en C#</strong></p>
<p>Se puede usar una instancia de <code>Caja</code> con cualquier tipo de dato.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Caja</span>&lt;T&gt;
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> T Contenido { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Posibles implementaciones en el programa</span>
</span></span><span style="display:flex;"><span>Caja caja1 = <span style="color:#66d9ef">new</span> Caja&lt;<span style="color:#66d9ef">int</span>&gt; { Contenido = <span style="color:#ae81ff">100</span> }; 
</span></span><span style="display:flex;"><span>Caja caja2 = <span style="color:#66d9ef">new</span> Caja&lt;<span style="color:#66d9ef">string</span>&gt; { Contenido = <span style="color:#e6db74">&#34;Hola&#34;</span> };
</span></span></code></pre></div><h4 id="cardinalidad">Cardinalidad<a hidden class="anchor" aria-hidden="true" href="#cardinalidad">#</a></h4>
<p>Expresa las relaciones entre clases, mediante el número de entidades a las que otra entidad puede estar relacionada. Cada caso se puede dar según los requerimientos del sistema.</p>
<ul>
<li><strong>1 a 1</strong>: Cada instancia de una clase se relaciona con <strong>una sola</strong> instancia de la otra clase. <strong>Ejemplo</strong>: Un <code>Docente</code> imparte <strong>exactamente un</strong> <code>Curso</code>, y ese <code>Curso</code> es impartido por <strong>exactamente un</strong> <code>Docente</code>.</li>
<li><strong>1 a muchos</strong>: Una instancia de una clase se relaciona con <strong>múltiples</strong> instancias de otra clase, pero no al revés. <strong>Ejemplo:</strong> Un <code>Docente</code> puede impartir <strong>muchos</strong> <code>Cursos</code>, pero cada <code>Curso</code> es impartido por <strong>solo un</strong> <code>Docente</code>.</li>
<li><strong>Muchos a muchos</strong>: Varias instancias de una clase se pueden relacionar con <strong>varias</strong> instancias de otra clase, y viceversa. <strong>Ejemplo:</strong> Un <code>Docente</code> puede impartir varios <code>Cursos</code>, y un mismo <code>Curso</code> puede ser impartido por varios <code>Docentes</code> (por ejemplo, en equipo).</li>
</ul>
<h3 id="23-tipos-de-datos-no-primitivos">2.3 Tipos de datos no primitivos<a hidden class="anchor" aria-hidden="true" href="#23-tipos-de-datos-no-primitivos">#</a></h3>
<p>Los tipos de datos no primitivos son estructuras más complejas que los datos simples y se crean a partir de estos. Algunos de los tipos más comunes son:</p>
<ul>
<li><strong>Objetos</strong>: Instancias de clases que combinan datos (atributos) y funcionalidades (métodos).</li>
<li><strong>Arreglos (Arrays)</strong>: Conjuntos de elementos del mismo tipo organizados de manera que cada valor se almacena en una posición específica identificada por un índice.</li>
<li><strong>Matrices</strong>: Son arreglos de dos o más dimensiones que organizan los datos en filas y columnas, permitiendo representar estructuras como tablas o gráficos.</li>
<li><strong>Listas</strong>: Son colecciones dinámicas de elementos, similares a los arreglos, pero con la diferencia de que pueden cambiar de tamaño y permiten agregar o eliminar datos con facilidad.</li>
</ul>
<h3 id="24-documentación-y-buenas-prácticas">2.4 Documentación y buenas prácticas<a hidden class="anchor" aria-hidden="true" href="#24-documentación-y-buenas-prácticas">#</a></h3>
<h4 id="recomendaciones">Recomendaciones<a hidden class="anchor" aria-hidden="true" href="#recomendaciones">#</a></h4>
<ul>
<li><strong>Manejo de accesos</strong>: Por defecto, se recomienda colocar cualquier dato como <em>privado</em>. En el caso de los constructores, se recomienda que siempre sean públicos salvo en casos especiales.</li>
<li><strong>Creación de constructores</strong>: Incluir un constructor si la clase tiene atributos.</li>
<li><strong>Reducir el Scope o ámbito</strong>: Los datos deben tener el ámbito lo más pequeño posible para facilitar la solución de errores.</li>
<li><strong>Reducir la interdependencia</strong>: Las clases deben ser concisas. Cambiar el código en una clase no debe afectar a otra clase. Los cambios en las interfases deben evitarse.</li>
<li><strong>Abstraer código no portable</strong>: Si tenemos código que no se puede llevar a otra plataforma, lo mejor es abstraerlo dentro de su propia clase.</li>
<li><strong>Pensar en la persistencia</strong>: Es importante pensar en la manera en la que se guardarán lo datos, ya sea en forma de un archivo en disco, en una base de datos relacional o en una base de datos orientada a objetos.</li>
<li><strong>Código limpio y mantenible</strong>: El código debe usar cada elemento de la forma adecuada. Se deben tener convenios (patrones) para nombrar cada elemento del código.</li>
</ul>
<p><strong>Ejemplo código &ldquo;sucio&rdquo;</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a1, a2, a3;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span>(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  a1++;
</span></span><span style="display:flex;"><span>  a2 =  a1*<span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>  a3 = a1+a2;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(a3&gt;<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Problemas:</p>
<ul>
<li>Varias variables declaradas en una misma línea y con nombres ambiguos.</li>
<li>No se han inicializado las variables.</li>
<li>Uso de un ciclo infinito con salida forzada, en lugar de usar la condición que provee.</li>
</ul>
<h4 id="documentación-del-código">Documentación del código<a hidden class="anchor" aria-hidden="true" href="#documentación-del-código">#</a></h4>
<p>Se documenta el inicio de la clase, los atributos y los métodos.</p>
<p><strong>Ejemplos</strong></p>
<p>Para el inicio de las <strong>clases</strong> se puede usar este formato:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">/// Descripción breve.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// Autor: AUTOR</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// Fecha: DD-MM-YY</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// Versión: 1.0.0</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// Modificación: DD-MM-YY</span>
</span></span></code></pre></div><p>Para el inicio de los <strong>métodos</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">/// Descripción breve.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// Autor: AUTOR</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// Fecha: DD-MM-YY</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// Versión: 1.0.0</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// Modificación: DD-MM-YY</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;param name=&#34;&#34;&gt; &lt;/param&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;param name=&#34;&#34;&gt; &lt;/param&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;returns&gt; &lt;/returns&gt;</span>
</span></span></code></pre></div><p>Para los <strong>atributos</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">double</span> resultado; <span style="color:#75715e">// Descripción muy breve.</span>
</span></span></code></pre></div><p>En el caso de elementos que estén dentro de los métodos, solo se documenta lo relevante, más no cada línea.</p>
<h4 id="diagrama-de-clases">Diagrama de clases<a hidden class="anchor" aria-hidden="true" href="#diagrama-de-clases">#</a></h4>
<p>Se usa para modelar la estructura de clases en la programación orientada a objetos. Muestra las clases, sus atributos, métodos y relaciones (herencia, asociación, composición, etc.).</p>
<p><img alt="Plataformas Abiertas 1_05-06-2025-7.png" loading="lazy" src="/imagenes/Plataformas%20Abiertas%201_05-06-2025-7.png"></p>
<p>Las relaciones entre clases se representan de diferente manera:</p>
<table>
  <thead>
      <tr>
          <th><strong>Relación</strong></th>
          <th><strong>Significado</strong></th>
          <th><strong>Representación</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Dependencia</strong></td>
          <td>&ldquo;Usa&rdquo;</td>
          <td>Línea punteada con flecha abierta <code>----&gt;</code></td>
      </tr>
      <tr>
          <td><strong>Asociación</strong></td>
          <td>&ldquo;Conoce a&rdquo; / &ldquo;Trabaja con&rdquo;</td>
          <td>Línea continua con flechas abiertas <code>──&gt;</code></td>
      </tr>
      <tr>
          <td><strong>Agregación</strong></td>
          <td>&ldquo;Tiene un&rdquo; (existe por separado)</td>
          <td>Línea con rombo blanco <code>----◊</code></td>
      </tr>
      <tr>
          <td><strong>Composición</strong></td>
          <td>&ldquo;Tiene un&rdquo; (no existe por separado)</td>
          <td>Línea con rombo negro <code>----◆</code></td>
      </tr>
      <tr>
          <td><strong>Herencia</strong></td>
          <td>&ldquo;Es un&rdquo;</td>
          <td>Línea con flecha triangular vacía <code>──▷</code></td>
      </tr>
  </tbody>
</table>
<p><img alt="Programación Orientada a Objetos_21-07-2025.png" loading="lazy" src="/imagenes/Programaci%C3%B3n%20Orientada%20a%20Objetos_21-07-2025.png"></p>
<h2 id="iii-ciclo-de-vida-de-un-objeto">III. Ciclo de vida de un objeto<a hidden class="anchor" aria-hidden="true" href="#iii-ciclo-de-vida-de-un-objeto">#</a></h2>
<h3 id="31-creación-del-objeto">3.1 Creación del objeto<a hidden class="anchor" aria-hidden="true" href="#31-creación-del-objeto">#</a></h3>
<h4 id="constructores">Constructores<a hidden class="anchor" aria-hidden="true" href="#constructores">#</a></h4>
<p>Los constructores son métodos especiales que se ejecutan automáticamente cuando se crea una instancia de una clase (objeto). Su función principal es inicializar el objeto, asignando valores iniciales a sus atributos si es necesario.</p>
<p>Algunas características clave son:</p>
<ul>
<li>Tienen el mismo nombre que la clase en la que está definido.</li>
<li>No tienen un tipo de retorno (ni siquiera <code>void</code>).</li>
<li>Suelen ser públicos para permitir la creación de instancias.</li>
<li>Si no se programa un constructor explícitamente, algunos lenguajes como C# generan un constructor vacío por defecto (<code>default</code>) que invoca al constructor de la clase base y permite crear instancias sin inicializar valores específicos.</li>
<li>Si nuestra clase tiene atributos es buena práctica incluir un constructor.</li>
</ul>
<p><strong>Ejemplo en C#</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Persona</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Atributos de la clase</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Nombre;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Edad;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Constructor de la clase</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Persona(<span style="color:#66d9ef">string</span> pNombre, <span style="color:#66d9ef">int</span> pEdad)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Nombre = pNombre;
</span></span><span style="display:flex;"><span>        Edad = pEdad;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Método para mostrar información</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> MostrarInfo()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Console.WriteLine(<span style="color:#e6db74">$&#34;Nombre: {Nombre}, Edad: {Edad}&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="instanciación">Instanciación<a hidden class="anchor" aria-hidden="true" href="#instanciación">#</a></h4>
<p>Un constructor es invocado cuando se utiliza el operador de instanciación <code>new</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Creación de un objeto Persona utilizando el constructor</span>
</span></span><span style="display:flex;"><span>        Persona persona1 = <span style="color:#66d9ef">new</span> Persona(<span style="color:#e6db74">&#34;Juan&#34;</span>, <span style="color:#ae81ff">25</span>);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Invocación del método MostrarInfo() con los parámetros del objeto persona1</span>
</span></span><span style="display:flex;"><span>        persona1.MostrarInfo(); <span style="color:#75715e">// Salida: Nombre: Juan, Edad: 25</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="operadores-de-instanciación">Operadores de instanciación<a hidden class="anchor" aria-hidden="true" href="#operadores-de-instanciación">#</a></h5>
<p>Los operadores de instanciación se usan para crear nuevos objetos en memoria. Su propósito es asignar espacio y ejecutar el constructor de una clase o estructura para inicializarla. Gracias a estos operadores, podemos trabajar con objetos de manera flexible y reutilizar código fácilmente.</p>
<ul>
<li>
<p><strong><code>new</code></strong>: Crea una nueva instancia de una clase, estructura, arreglo o delegado. Llama automáticamente al constructor de la clase o estructura.</p>
<p><strong>Ejemplo en C#</strong></p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Persona juan = <span style="color:#66d9ef">new</span> Persona();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span>[] numeros = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">5</span>];
</span></span></code></pre></div><ul>
<li>
<p><strong><code>typeof</code></strong>: Devuelve un objeto <code>Type</code> que representa un tipo en tiempo de ejecución. No crea una instancia, pero es útil para obtener información sobre un tipo.</p>
<p><strong>Ejemplo en C#</strong></p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Type tipoPersona = <span style="color:#66d9ef">typeof</span>(Persona);
</span></span></code></pre></div><ul>
<li>
<p><strong><code>Activator.CreateInstance&lt;T&gt;()</code></strong>: Crea dinámicamente una instancia de una clase sin usar <code>new</code>. Útil cuando el tipo se desconoce en tiempo de compilación.</p>
<p><strong>Ejemplo en C#</strong></p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Persona juan = Activator.CreateInstance&lt;Persona&gt;();
</span></span></code></pre></div><ul>
<li>
<p><strong><code>default</code></strong>: Asigna el valor predeterminado a un tipo. Para tipos de referencia, devuelve <code>null</code>. Para tipos de valor, devuelve <code>0</code>, <code>false</code> o equivalente.</p>
<p><strong>Ejemplo en C#</strong></p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Persona personaPorDefecto = <span style="color:#66d9ef">default</span>(Persona);  <span style="color:#75715e">// null</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> numero = <span style="color:#66d9ef">default</span>(<span style="color:#66d9ef">int</span>);  <span style="color:#75715e">// 0</span>
</span></span></code></pre></div><h3 id="33-uso-del-objeto">3.3 Uso del objeto<a hidden class="anchor" aria-hidden="true" href="#33-uso-del-objeto">#</a></h3>
<h4 id="acceso-a-atributos-y-métodos">Acceso a atributos y métodos<a hidden class="anchor" aria-hidden="true" href="#acceso-a-atributos-y-métodos">#</a></h4>
<p>Una vez que un objeto ha sido creado (instanciado), podemos acceder a sus atributos y métodos para realizar operaciones y manipular sus datos.</p>
<p>Se accede a los miembros de un objeto usando el operador punto (<code>.</code>).
Por ejemplo, si <code>persona1</code> es un objeto, <code>persona1.Nombre</code> accede al atributo <code>Nombre</code> y <code>persona1.MostrarInfo()</code> llama al método.</p>
<h3 id="34-alcance-y-duración-del-objeto">3.4 Alcance y duración del objeto<a hidden class="anchor" aria-hidden="true" href="#34-alcance-y-duración-del-objeto">#</a></h3>
<h4 id="variables-de-instancia-y-variables-locales">Variables de instancia y variables locales<a hidden class="anchor" aria-hidden="true" href="#variables-de-instancia-y-variables-locales">#</a></h4>
<ul>
<li><strong>Variables de instancia</strong>: Existen mientras el objeto esté en memoria y pertenecen a cada instancia.</li>
<li><strong>Variables locales</strong>: Solo existen dentro del método donde se declaran y desaparecen al terminar la ejecución de ese método.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Animal</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">string</span> nombre; <span style="color:#75715e">// Variable de instancia</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> AsignarNombre()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">string</span> mensaje = <span style="color:#e6db74">&#34;Nombre asignado&#34;</span>; <span style="color:#75715e">// Variable local</span>
</span></span><span style="display:flex;"><span>        nombre = <span style="color:#e6db74">&#34;Perro&#34;</span>;
</span></span><span style="display:flex;"><span>        Console.WriteLine(mensaje);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="35-destrucción-y-gestión-de-memoria">3.5 Destrucción y gestión de memoria<a hidden class="anchor" aria-hidden="true" href="#35-destrucción-y-gestión-de-memoria">#</a></h3>
<p>En C#, la gestión de memoria es automática gracias al recolector de basura (GC), que elimina objetos cuando ya no se usan. No es necesario liberar memoria manualmente en la mayoría de los casos.</p>
<p>Para liberar recursos externos como archivos, conexiones o streams, se usa el patrón <code>Dispose()</code> junto con la palabra clave <code>using</code>. Esto garantiza que el recurso se cierre correctamente al terminar su uso.</p>
<p><strong>Ejemplo en C#</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> (StreamReader lector = <span style="color:#66d9ef">new</span> StreamReader(<span style="color:#e6db74">&#34;archivo.txt&#34;</span>))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">string</span> linea = lector.ReadLine();
</span></span><span style="display:flex;"><span>    Console.WriteLine(linea);
</span></span><span style="display:flex;"><span>} <span style="color:#75715e">// Aquí se llama automáticamente a Dispose()</span>
</span></span></code></pre></div><h4 id="destructores">Destructores<a hidden class="anchor" aria-hidden="true" href="#destructores">#</a></h4>
<p>Los destructores sirven para limpiar memoria, cerrar archivos, o finalizar cualquier cosa que lo requiera, y se invocan automáticamente cuando el objeto deja de existir. No todos los lenguajes lo implementan. Lleva el mismo nombre de la clase pero lleva <code>~</code> al inicio.</p>
<h2 id="iv-mecanismos-de-poo">IV. Mecanismos de POO<a hidden class="anchor" aria-hidden="true" href="#iv-mecanismos-de-poo">#</a></h2>
<h3 id="41-encapsulación-y-acceso">4.1 Encapsulación y acceso<a hidden class="anchor" aria-hidden="true" href="#41-encapsulación-y-acceso">#</a></h3>
<p>La encapsulación es un principio fundamental de la POO que protege los datos dentro de un objeto y regula su acceso. Para lograrlo, se emplean los <em>controles de acceso</em>, los cuales determinan:</p>
<ul>
<li><strong>Visibilidad</strong>: Define qué partes del código pueden acceder a los atributos y métodos.</li>
<li><strong>Manipulación</strong>: Controla cómo y cuándo los atributos de un objeto pueden modificarse.</li>
</ul>
<p>El uso adecuado de estos controles permite garantizar que solo las partes autorizadas del código puedan interactuar con su contenido. Para ello, se deben comprender los <em>modificadores de acceso</em> y los métodos específicos que permiten acceder o modificar los datos de manera segura (<em>accessors</em> y <em>mutators</em>).</p>
<h4 id="modificadores-de-acceso">Modificadores de acceso<a hidden class="anchor" aria-hidden="true" href="#modificadores-de-acceso">#</a></h4>
<p>Utilizando estos modificadores podemos indicar el tipo de acceso a los datos del programa. Estos se colocan antes de la declaración de la clase, atributo o método, y se pueden combinar según sea requerido.</p>
<ul>
<li><strong>Público (public)</strong>: El exterior tiene acceso.</li>
<li><strong>Privado (private)</strong>: Solo el mismo objeto puede acceder.</li>
<li><strong>Protegido (protected)</strong>: Únicamente tienen acceso los objetos dentro de la cadena de herencia.</li>
<li><strong>Estático (static)</strong>: Indica que un atributo o método pertenece a una clase y puede ser utilizado por todas sus instancias.</li>
<li><strong>Final (final)</strong>: Vuelve inmutable a un elemento:
<ul>
<li><strong>En atributos</strong>, evita que el valor cambie después de su inicialización.</li>
<li><strong>En métodos</strong>, evita que sea sobrescrito por una clase heredada.</li>
<li><strong>En clases</strong>, evita que la clase sea heredada.</li>
</ul>
</li>
</ul>
<h4 id="accessors">Accessors<a hidden class="anchor" aria-hidden="true" href="#accessors">#</a></h4>
<p>Por defecto, todos los atributos deben ser privados, por lo que para poder acceder a ellos se utilizan los accessors, los cuales permiten el acceso a los datos internos de un objeto por medio de reglas controladas. Pueden implementarse mediante métodos (<em>getters</em> y <em>setters</em> tradicionales) o <em>propiedades</em>:</p>
<h5 id="funciones-de-interfaz">Funciones de interfaz<a hidden class="anchor" aria-hidden="true" href="#funciones-de-interfaz">#</a></h5>
<ul>
<li><strong>Getters</strong>: Métodos que devuelven el valor de un atributo.</li>
</ul>
<p><strong>Ejemplo en C#</strong></p>
<p>Método que permite obtener el valor del atributo <code>edad</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> getEdad() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> edad;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>Setters</strong>: Métodos que permiten asignar un nuevo valor a un atributo.</li>
</ul>
<p><strong>Ejemplo en C#</strong></p>
<p>Método que permite asignar un nuevo valor al atributo <code>edad</code>, asegurando que solo se permita si <code>nuevaEdad</code> es mayor a <code>0</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> setEdad(<span style="color:#66d9ef">int</span> nuevaEdad) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (nuevaEdad &gt; <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.edad = nuevaEdad;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="propiedades">Propiedades<a hidden class="anchor" aria-hidden="true" href="#propiedades">#</a></h5>
<p>Se suelen utilizar propiedades Getter y Setter en lugar de los métodos.</p>
<p><strong>Ejemplo en C#</strong></p>
<p>Método donde <code>get</code> permite obtener el valor de <code>edad</code>, mientras que el <code>set</code> permite modificar <code>edad</code> solo si <code>value</code> es mayor a <code>0</code>. <code>value</code> es una palabra asignada en C# que representa el valor que se intenta asignar.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">// Se declara la variable como private</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> edad;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Se declara la propiedad como public para que pueda ser accesada. Se cambia a PascalCase.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Edad {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">get</span> { <span style="color:#66d9ef">return</span> edad; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">set</span> { <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">value</span> &gt; <span style="color:#ae81ff">0</span>) edad = <span style="color:#66d9ef">value</span>; }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="mutators">Mutators<a hidden class="anchor" aria-hidden="true" href="#mutators">#</a></h4>
<p>Son aquellos métodos que permiten modificar progresivamente el estado interno del objeto. Aunque los setters también son mutators, no todos los mutators son setters.</p>
<p><strong>Ejemplo en C#</strong></p>
<p>Método que incrementa el valor de <code>saldo</code> sumando a este el valor de <code>cantidad</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> depositar(<span style="color:#66d9ef">double</span> cantidad) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (cantidad &gt; <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		saldo += cantidad;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="ámbito-o-scope">Ámbito o scope<a hidden class="anchor" aria-hidden="true" href="#ámbito-o-scope">#</a></h4>
<p>El ámbito (scope) en POO define la zona del código donde una variable, atributo o método es accesible. Este concepto es esencial para controlar la visibilidad y el uso de los datos dentro de una clase o función.</p>
<p>En C#, el ámbito de una variable o método se define según dónde y cómo se declara:</p>
<ul>
<li><strong>Ámbito de variables locales</strong>: Una variable declarada dentro de un método solo existe dentro de ese método y no puede ser accedida fuera de él.</li>
<li><strong>Ámbito de atributos de clase</strong>: Un atributo declarado dentro de una clase pero fuera de cualquier método puede ser accedido por los métodos de la misma clase y, dependiendo de su modificador de acceso, por otras clases.</li>
<li><strong>Ámbito de parámetros</strong>: Los parámetros de un método solo existen dentro del método donde fueron declarados y no pueden ser accedidos fuera de él.</li>
</ul>
<p><strong>Ejemplo en C#</strong></p>
<p>Tenemos una clase <code>Coche</code> que almacena la marca de un automóvil. Usamos diferentes tipos de variables para demostrar cómo el ámbito (scope) afecta su uso. Esto ayuda a entender qué variables pueden usarse en distintos lugares del código y cuáles solo existen por un momento.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Coche</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Variable de instancia (ámbito de clase)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">string</span> marca;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Método para asignar una marca al coche</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> AsignarMarca(<span style="color:#66d9ef">string</span> nuevaMarca)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Variable local (solo existe dentro de este método)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">string</span> mensaje = <span style="color:#e6db74">&#34;Marca asignada correctamente.&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Asignamos el valor del parámetro a la variable de instancia</span>
</span></span><span style="display:flex;"><span>        marca = nuevaMarca;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Mostramos el mensaje</span>
</span></span><span style="display:flex;"><span>        Console.WriteLine(mensaje);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Método para obtener la marca del coche</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> ObtenerMarca()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> marca;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Coche miCoche = <span style="color:#66d9ef">new</span> Coche();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Llamamos al método y pasamos un parámetro</span>
</span></span><span style="display:flex;"><span>        miCoche.AsignarMarca(<span style="color:#e6db74">&#34;Toyota&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Mostramos la marca asignada</span>
</span></span><span style="display:flex;"><span>        Console.WriteLine(<span style="color:#e6db74">&#34;La marca del coche es: &#34;</span> + miCoche.ObtenerMarca());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="this">This<a hidden class="anchor" aria-hidden="true" href="#this">#</a></h5>
<p>Cuando una variable local o un parámetro de método tiene el mismo nombre que un atributo de clase, se puede usar la palabra clave <code>this</code> para diferenciar entre ambos.</p>
<p><strong>Ejemplo en C#</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Coche</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">string</span> marca;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> AsignarMarca(<span style="color:#66d9ef">string</span> marca)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Sin this: se refiere al parámetro</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Con this: se refiere al atributo de la instancia</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.marca = marca;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="static">Static<a hidden class="anchor" aria-hidden="true" href="#static">#</a></h5>
<p>La palabra clave <code>static</code> se utiliza para declarar atributos o métodos que pertenecen a la clase y a todas sus instancias y se puede acceder a él sin crear un objeto de la clase.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Contador</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Atributo estático compartido por todos los objetos</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> totalObjetos = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Contador()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Al crear una nueva instancia, incrementamos el contador compartido</span>
</span></span><span style="display:flex;"><span>        totalObjetos++;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> MostrarTotal()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Console.WriteLine(<span style="color:#e6db74">&#34;Total de objetos creados: &#34;</span> + totalObjetos);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Contador c1 = <span style="color:#66d9ef">new</span> Contador();
</span></span><span style="display:flex;"><span>        Contador c2 = <span style="color:#66d9ef">new</span> Contador();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Llamamos a un método estático sin crear una instancia</span>
</span></span><span style="display:flex;"><span>        Contador.MostrarTotal(); <span style="color:#75715e">// Output: Total de objetos creados: 2</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="42-abstracción-e-interfaces-propias">4.2 Abstracción e interfaces propias<a hidden class="anchor" aria-hidden="true" href="#42-abstracción-e-interfaces-propias">#</a></h3>
<p>La abstracción es un principio que permite mostrar solo los elementos esenciales de un objeto al usuario final, ocultando los detalles internos de su implementación. En otras palabras, se enfoca en &ldquo;qué hace&rdquo; un objeto en lugar de &ldquo;cómo lo hace&rdquo;, facilitando su uso para el usuario final sin necesidad de que conozca su funcionamiento interno. Un mecanismo clave para lograr la abstracción son las <em>interfaces</em>.</p>
<h4 id="interfaz-propia">Interfaz propia<a hidden class="anchor" aria-hidden="true" href="#interfaz-propia">#</a></h4>
<p>La interfaz es la forma fundamental de comunicación entre objetos, la cual es compuesta por aquellos atributos y métodos que necesitamos mostrar al exterior, y es aquella que define cómo los usuarios finales de esa clase/objeto interactúan con ella. Algunas características importantes son:</p>
<ul>
<li>Podemos empezar una clase sin interfaz y sólo crearla si es necesario. La interfaz debe ser mínima.</li>
<li>Hay que tomar en cuenta quién es el usuario y sus necesidades.</li>
<li>La interfaz incluye la sintaxis para invocar al método y saber lo que regresa.</li>
<li>Requiere de una <em>implementación</em> para ser efectiva.</li>
</ul>
<p><strong>Ejemplo en C#</strong></p>
<p>La interfaz declara el método <code>HacerSonido()</code>, pero no dice cómo debe hacerlo.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IAnimal</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> HacerSonido(); <span style="color:#75715e">// Solo se declara, sin implementación</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="implementación">Implementación<a hidden class="anchor" aria-hidden="true" href="#implementación">#</a></h5>
<p>Para que una clase esté bien construida se requiere la interfaz y la implementación. Mientras que la interfaz define un método pero no el cómo, la implementación define cómo funcionan esos métodos.</p>
<p><strong>Ejemplo en C#</strong></p>
<p>Aquí la clase <code>Perro</code> implementa la interfaz <code>IAnimal</code> y le da su propio comportamiento.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Perro</span> : IAnimal <span style="color:#75715e">//Implementa la interfaz</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Se define el comportamiento</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> HacerSonido() {
</span></span><span style="display:flex;"><span>        Console.WriteLine(<span style="color:#e6db74">&#34;¡Guau!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Aquí la clase <code>Gato</code> implementa la interfaz <code>IAnimal</code> y le da su propio comportamiento.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Gato</span> : IAnimal <span style="color:#75715e">//Implementa la interfaz</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Se define el comportamiento</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> HacerSonido() {
</span></span><span style="display:flex;"><span>        Console.WriteLine(<span style="color:#e6db74">&#34;¡Miau!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Ahora creamos un objeto <code>Perro</code> y llamamos su método <code>HacerSonido()</code>. Hacemos lo mismo con un objeto <code>Gato</code> Esto es la aplicación de la interfaz y la implementación.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Se crea un objeto de la clase Perro dentro de una variable de tipo IAnimal llamada Tomasina.</span>
</span></span><span style="display:flex;"><span>        IAnimal Tomasina = <span style="color:#66d9ef">new</span> Perro();
</span></span><span style="display:flex;"><span>	    <span style="color:#75715e">// Se aplica la interfaz e implementación. Salida: ¡Guau!</span>
</span></span><span style="display:flex;"><span>        Tomasina.HacerSonido();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Se crea un objeto de la clase Gato dentro de una variable de tipo IAnimal llamada Selina.</span>
</span></span><span style="display:flex;"><span>        IAnimal Selina = <span style="color:#66d9ef">new</span> Gato();
</span></span><span style="display:flex;"><span>	    <span style="color:#75715e">// Se aplica la interfaz e implementación. Salida: ¡Miau!</span>
</span></span><span style="display:flex;"><span>        Selina.HacerSonido();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="43-herencia-y-especialización">4.3 Herencia y especialización<a hidden class="anchor" aria-hidden="true" href="#43-herencia-y-especialización">#</a></h3>
<p>La herencia es una característica esencial en la reutilización de código, ya que permite que una clase herede el contenido de otra, es decir, permite que una clase aproveche los atributos y métodos de una ya existente sin tener que repetir el código, sino únicamente adicionando lo que le falte.</p>
<p>Al aplicar la herencia, se define primero la <em>clase principal</em>, que será la más abstracta, es decir, la que establece la estructura general sin implementar todos los detalles. Por su parte, las <em>clases heredadas</em>, más concretas, se encargan de implementar los detalles específicos del objeto.</p>
<p>Algunos lenguajes permiten la <em>herencia múltiple</em>, donde una clase hereda de más de una clase principal. Sin embargo, puede generar conflictos y aumentar la complejidad, por lo que lenguajes como C# y Java no la admiten y usan <em>interfaces</em> en su lugar.</p>
<h4 id="jerarquía-de-clases">Jerarquía de clases<a hidden class="anchor" aria-hidden="true" href="#jerarquía-de-clases">#</a></h4>
<ul>
<li><strong>Superclase (Clase padre)</strong>: Contiene todos los atributos y métodos que son comunes a las clases que descienden de ella. <em>Ej.</em> Persona.</li>
<li><strong>Subclase (Clase hija)</strong>: Es una extensión de la superclase, donde toma toda su información de esta y adiciona lo propio. <em>Ej.</em> Persona &ndash;&gt; Empleado.</li>
</ul>
<p>La relación &ldquo;es-un&rdquo; describe cómo se establece la herencia entre clases, ya que una clase hija hereda características y comportamientos de una clase padre.</p>
<h3 id="44-polimorfismo-dinámico-y-estático">4.4 Polimorfismo dinámico y estático<a hidden class="anchor" aria-hidden="true" href="#44-polimorfismo-dinámico-y-estático">#</a></h3>
<p>El polimorfismo es la capacidad que tiene un método para comportarse de distintas maneras según el objeto que lo esté usando.</p>
<p>Existen dos tipos:</p>
<ul>
<li><strong>Polimorfismo dinámico</strong>: El método se decide cuando el programa se está ejecutando, es decir, el programa elige qué método ejecutar mientras está corriendo.</li>
<li><strong>Polimorfismo estático</strong>: El método se elige antes de que el programa se ejecute, al compilar, es decir, el compilador elige cuál versión del método usar al momento de traducir el código.</li>
</ul>
<h4 id="sobreescritura-overriding">Sobreescritura (Overriding)<a hidden class="anchor" aria-hidden="true" href="#sobreescritura-overriding">#</a></h4>
<p>Es la técnica por la cual una subclase reemplaza la implementación de un método heredado de su clase padre, sin cambiar la estructura original.</p>
<p>Esto es útil porque las subclases pueden mantener la misma interfaz, pero con un comportamiento propio según sus necesidades.</p>
<p>La sobreescritura requiere de la herencia y se considera <em>dinámica</em> porque ocurre en el tiempo de ejecución.</p>
<p><strong>Ejemplo</strong></p>
<p>Se tiene una superclase llamada <code>Animal</code> con un método <code>HacerSonido()</code>. Cada subclase (como <code>Perro</code> o <code>Gato</code>) hereda este método, pero lo implementa de manera distinta:</p>
<ul>
<li><code>Perro.HacerSonido()</code> → 🐶 &ldquo;¡Guau!&rdquo;</li>
<li><code>Gato.HacerSonido()</code> → 🐱 &ldquo;¡Miau!&rdquo;</li>
</ul>
<h4 id="sobrecarga-overloading">Sobrecarga (Overloading)<a hidden class="anchor" aria-hidden="true" href="#sobrecarga-overloading">#</a></h4>
<p>Ocurre cuando hay varios métodos con el mismo nombre, pero con diferentes parámetros. El compilador decide cuál método usar dependiendo de los argumentos.</p>
<p>La sobrecarga no requiere de la herencia y se considera <em>estática</em> porque ocurre en el tiempo de compilación.</p>
<h5 id="sobrecarga-de-métodos">Sobrecarga de métodos<a hidden class="anchor" aria-hidden="true" href="#sobrecarga-de-métodos">#</a></h5>
<p>La sobrecarga de métodos permite definir varios métodos con el mismo nombre, pero con diferentes parámetros. Esto permite flexibilidad, ya que se pueden usar diferentes versiones del método según la necesidad.</p>
<p><strong>Reglas de sobrecarga</strong>:</p>
<ol>
<li>Deben tener el mismo nombre.</li>
<li>Deben diferenciarse por el número o tipo de parámetros.</li>
<li>No pueden diferenciarse solo por el tipo de retorno.</li>
</ol>
<p><strong>Ejemplo en C#</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Calculadora</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Método para sumar dos números enteros</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Sumar(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> a + b;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Sobrecarga del método para sumar tres números</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Sumar(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b, <span style="color:#66d9ef">int</span> c)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> a + b + c;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Calculadora calc = <span style="color:#66d9ef">new</span> Calculadora();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Uso del método con dos parámetros</span>
</span></span><span style="display:flex;"><span>        Console.WriteLine(calc.Sumar(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>)); <span style="color:#75715e">// Salida: 8</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Uso del método sobrecargado con tres parámetros</span>
</span></span><span style="display:flex;"><span>        Console.WriteLine(calc.Sumar(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">2</span>)); <span style="color:#75715e">// Salida: 10</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="sobrecarga-de-constructores">Sobrecarga de constructores<a hidden class="anchor" aria-hidden="true" href="#sobrecarga-de-constructores">#</a></h5>
<p>La sobrecarga implica tener más de una versión del constructor, diferenciándolos por la cantidad y tipo de parámetros que reciben. Esto nos da flexibilidad al instanciar objetos, ya que se pueden crear con diferentes niveles de información según las necesidades del programa.</p>
<p><strong>Ejemplo en C#</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Persona</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">string</span> nombre;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> edad;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Constructor con dos parámetros</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Persona(<span style="color:#66d9ef">string</span> nombre, <span style="color:#66d9ef">int</span> edad)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.nombre = nombre;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.edad = edad;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Constructor con solo el nombre (edad por defecto)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Persona(<span style="color:#66d9ef">string</span> nombre)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.nombre = nombre;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.edad = <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// Valor por defecto</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> MostrarInfo()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Console.WriteLine(<span style="color:#e6db74">$&#34;Nombre: {nombre}, Edad: {edad}&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Usando el constructor con nombre y edad</span>
</span></span><span style="display:flex;"><span>        Persona persona1 = <span style="color:#66d9ef">new</span> Persona(<span style="color:#e6db74">&#34;Juan&#34;</span>, <span style="color:#ae81ff">25</span>);
</span></span><span style="display:flex;"><span>        persona1.MostrarInfo(); <span style="color:#75715e">// Salida: Nombre: Juan, Edad: 25</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Usando el constructor con solo el nombre</span>
</span></span><span style="display:flex;"><span>        Persona persona2 = <span style="color:#66d9ef">new</span> Persona(<span style="color:#e6db74">&#34;Ana&#34;</span>);
</span></span><span style="display:flex;"><span>        persona2.MostrarInfo(); <span style="color:#75715e">// Salida: Nombre: Ana, Edad: 0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="sobrecarga-de-operadores">Sobrecarga de operadores<a hidden class="anchor" aria-hidden="true" href="#sobrecarga-de-operadores">#</a></h5>
<p>La sobrecarga de operadores es una técnica que permite redefinir el comportamiento de operadores ( +,  -,  *,  ==, etc.) cuando se usan con objetos de una clase personalizada, más no reemplaza su función original en el programa. Es decir, en lugar de recurrir a métodos tradicionales para realizar ciertas operaciones, la sobrecarga permite que los objetos interactúen de forma más intuitiva, como si estos fueran tipos de datos sencillos.</p>
<p>La sobrecarga de operadores se usa cuando queremos que las operaciones con objetos sean más naturales en lugar de depender de métodos específicos. Sin embargo, no todos los operadores son sobrecargables, y su abuso puede hacer que el código sea menos claro si no se usan adecuadamente.</p>
<p>Sus características principales son:</p>
<ul>
<li>El significado de un operador puede cambiar según los tipos de datos que opera.</li>
<li>Se puede definir el comportamiento de los operadores para que actúen sobre nuestros propios tipos.</li>
<li>No todos los lenguajes de programación permiten la sobrecarga de operadores.</li>
<li>La sobrecarga debe ser implementada de manera que mantenga la lógica esperada del operador y no genere confusión.</li>
</ul>
<p><strong>Ejemplo en C#</strong></p>
<p>Vamos a sobrecargar el operador <code>+</code> para que pueda sumar dos objetos <code>Punto</code>, combinando sus coordenadas <code>x</code> e <code>y</code>. Sin esta sobrecarga, <code>PuntoA + PuntoB</code> daría error, pero al definir su comportamiento, podemos hacer que devuelva un nuevo punto con la suma de las coordenadas.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Punto</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Propiedades para almacenar las coordenadas X e Y</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> X { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Y { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Constructor que inicializa un punto con valores X e Y</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Punto(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        X = x;
</span></span><span style="display:flex;"><span>        Y = y;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Sobrecarga del operador + para sumar dos objetos Punto</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Punto <span style="color:#66d9ef">operator</span> +(Punto a, Punto b)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Devuelve un nuevo Punto con la suma de las coordenadas</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Punto(a.X + b.X, a.Y + b.Y);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Método para mostrar el punto en consola</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Mostrar()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Console.WriteLine(<span style="color:#e6db74">$&#34;Punto ({X}, {Y})&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Creación de dos objetos Punto</span>
</span></span><span style="display:flex;"><span>        Punto p1 = <span style="color:#66d9ef">new</span> Punto(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>        Punto p2 = <span style="color:#66d9ef">new</span> Punto(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Uso de la sobrecarga del operador + para sumar los puntos</span>
</span></span><span style="display:flex;"><span>        Punto resultado = p1 + p2; <span style="color:#75715e">// Equivalente a resultado = new Punto(6, 8);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Muestra el resultado en consola</span>
</span></span><span style="display:flex;"><span>        resultado.Mostrar(); <span style="color:#75715e">// Salida: Punto (6, 8)</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h6 id="sobrecarga-de-operadores-aritméticos">Sobrecarga de operadores aritméticos<a hidden class="anchor" aria-hidden="true" href="#sobrecarga-de-operadores-aritméticos">#</a></h6>
<ul>
<li><strong><code>+</code> (suma)</strong> → Puede sumar dos objetos, como combinar coordenadas de dos puntos o concatenar información personalizada.
<strong>Ejemplo</strong>: <code>VectorA + VectorB</code> suma sus componentes y devuelve un nuevo vector.</li>
<li><strong><code>-</code> (resta)</strong> → Puede definir una diferencia entre objetos, como restar valores de dos cuentas bancarias.
<strong>Ejemplo</strong>: <code>CuentaA - CuentaB</code> podría calcular la diferencia de saldo.</li>
<li><strong><code>*</code> (multiplicación)</strong> → Puede escalar objetos, como multiplicar un vector por un número.
<strong>Ejemplo</strong>: <code>Vector * 2</code> duplica sus valores.</li>
<li><strong><code>/</code> (división)</strong> → Puede definir una relación entre objetos, como dividir un objeto en partes.
Ejemplo: <code>Pizza / 4</code> podría representar repartir la pizza en 4 porciones.</li>
</ul>
<h6 id="sobrecarga-de-operadores-de-comparación">Sobrecarga de operadores de comparación<a hidden class="anchor" aria-hidden="true" href="#sobrecarga-de-operadores-de-comparación">#</a></h6>
<ul>
<li><strong>== (igualdad)</strong> → Compara si dos objetos son equivalentes según sus atributos.
<strong>Ejemplo</strong>: <code>PersonaA</code> == <code>PersonaB</code> podría verificar si tienen el mismo nombre y edad.</li>
<li><strong>!= (desigualdad)</strong> → Verifica si dos objetos son distintos.
<strong>Ejemplo</strong>: <code>AutoA</code> != <code>AutoB</code> podría comparar si tienen diferentes placas.</li>
<li>** &lt; y  &gt; (menor o mayor que)** → Permiten comparar objetos según un criterio específico.
<strong>Ejemplo</strong>: <code>EmpleadoA &gt; EmpleadoB</code> podría significar que gana más salario.</li>
</ul>
<h6 id="sobrecarga-de-operadores-de-incrementodecremento">Sobrecarga de operadores de incremento/decremento<a hidden class="anchor" aria-hidden="true" href="#sobrecarga-de-operadores-de-incrementodecremento">#</a></h6>
<ul>
<li><strong><code>++</code> (incremento)</strong> → Puede aumentar el valor de un objeto.
<strong>Ejemplo</strong>: <code>Nivel++</code> podría aumentar el nivel de un personaje en un juego.</li>
<li><strong><code>--</code> (decremento)</strong> → Puede reducir el valor de un objeto.
<strong>Ejemplo</strong>: <code>Cupo--</code> podría disminuir la cantidad de espacios disponibles en un evento.</li>
</ul>
<h6 id="sobrecarga-de-operadores-de-conversión">Sobrecarga de operadores de conversión<a hidden class="anchor" aria-hidden="true" href="#sobrecarga-de-operadores-de-conversión">#</a></h6>
<ul>
<li><strong><code>explicit</code> / <code>implicit</code></strong> → Permiten convertir un objeto en otro tipo.
<strong>Ejemplo</strong>: <code>Producto</code> podría convertirse en <code>string</code> para mostrar su nombre en una factura.</li>
</ul>
<h3 id="45-composición">4.5 Composición<a hidden class="anchor" aria-hidden="true" href="#45-composición">#</a></h3>
<p>La composición es un principio en el que un objeto está formado por otros objetos, estableciendo una relación de dependencia entre ellos. En programación, este enfoque nos ayuda a la reutilización de código y la modularidad, permitiéndonos construir clases complejas combinando múltiples clases más pequeñas y especializadas.</p>
<p>La relación &ldquo;tiene-un&rdquo; describe cómo se establece la composición entre clases, ya que un objeto posee o contiene otros objetos en su interior.</p>
<h4 id="decoración">Decoración<a hidden class="anchor" aria-hidden="true" href="#decoración">#</a></h4>
<p>Es un patrón de diseño que permite envolver un objeto en tiempo de ejecución con otro objeto para extender o modificar su comportamiento sin tener que crear otras sub clases.</p>
<p>También se definen dos tipos de decoradores:</p>
<ul>
<li>
<p><strong>Decorador base</strong>: Clase que implementa la misma interfaz que el componente original y contiene una referencia al objeto que se desea decorar.</p>
</li>
<li>
<p><strong>Decorador concreto</strong>: Clase que extiende al decorador base y agrega funcionalidades específicas.</p>
</li>
<li>
<p>Interfaz</p>
<ul>
<li>Clase Base
<ul>
<li>Decorador base
<ul>
<li>Decorador conceto</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="v-estructuras-de-datos-abstractos">V. Estructuras de datos abstractos<a hidden class="anchor" aria-hidden="true" href="#v-estructuras-de-datos-abstractos">#</a></h2>
<p>En POO, son modelos que permiten organizar y gestionar datos de manera eficiente. Estas estructuras permiten almacenar objetos y manipularlos según ciertas reglas de acceso y recorrido.</p>
<h3 id="51-estructuras-de-datos-lineales">5.1 Estructuras de datos lineales<a hidden class="anchor" aria-hidden="true" href="#51-estructuras-de-datos-lineales">#</a></h3>
<p>Son aquellas estructuras donde los elementos están organizados de forma secuencial, uno después del otro.</p>
<h4 id="arreglo-array">Arreglo (Array)<a hidden class="anchor" aria-hidden="true" href="#arreglo-array">#</a></h4>
<p>Un arreglo es una colección de tamaño fijo que almacena elementos del mismo tipo en posiciones contiguas de memoria. A diferencia de estructuras como las listas, los arreglos no pueden crecer o reducirse después de su creación. Además, el índice con el que inicia es 0.</p>
<p>Se usa cuando se conoce el número exacto de elementos y no se necesita cambiar su tamaño, como al tener registros fijos.</p>
<p><strong>Ejemplo en C#</strong></p>
<p>Se crea un arreglo con tres enteros. Si quieres acceder al segundo elemento: <code>numeros[1]</code> devuelve <code>20</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span>[] numeros = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">3</span>] { <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span> };
</span></span></code></pre></div><h5 id="referenciar-objetos">Referenciar objetos<a hidden class="anchor" aria-hidden="true" href="#referenciar-objetos">#</a></h5>
<p>Un arreglo también puede contener objetos. Al acceder a un elemento se obtiene una referencia, no una copia.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>CAuto miAuto = miTienda[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// miAuto apunta al mismo objeto que está en el índice 1 del arreglo</span>
</span></span></code></pre></div><p>Esto significa que si se modifica <code>miAuto</code>, también se está modificando <code>miTienda[1]</code>, porque ambos apuntan al mismo espacio en memoria.</p>
<h5 id="indexer">Indexer<a hidden class="anchor" aria-hidden="true" href="#indexer">#</a></h5>
<p>Es una especie de propiedad para arreglos, que permite acceder a una colección. En C#, solo se puede tener uno por clase. Colocar un indexer nos permite poner el arreglo en privado.</p>
<p><strong>Ejemplo en C#</strong></p>
<p>Implementación del indexer.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TiendaAutos</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> CAuto[] autos = <span style="color:#66d9ef">new</span> CAuto[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> CAuto <span style="color:#66d9ef">this</span>[<span style="color:#66d9ef">int</span> i]
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">get</span> =&gt; autos[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">set</span> =&gt; autos[i] = <span style="color:#66d9ef">value</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Esto permite ocultar directamente el arreglo autos y accederlo desde fuera con:</span>
</span></span><span style="display:flex;"><span>CAuto miAuto = tienda[<span style="color:#ae81ff">2</span>];
</span></span></code></pre></div><h4 id="lista-ligada-linked-list">Lista Ligada (Linked List)<a hidden class="anchor" aria-hidden="true" href="#lista-ligada-linked-list">#</a></h4>
<p>Una lista ligada es una colección donde cada elemento (nodo) apunta al siguiente. No hay acceso directo por índice, sino que se recorre desde el inicio.</p>
<p>Se usa cuando necesitas insertar o eliminar elementos frecuentemente en cualquier parte de la lista.</p>
<p><strong>Ejemplo en C#</strong></p>
<p>Se crea una lista ligada de nombres. En este caso el recorrido se hace con un ciclo.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>LinkedList&lt;<span style="color:#66d9ef">string</span>&gt; nombres = <span style="color:#66d9ef">new</span> LinkedList&lt;<span style="color:#66d9ef">string</span>&gt;();
</span></span><span style="display:flex;"><span>nombres.AddLast(<span style="color:#e6db74">&#34;Ana&#34;</span>);
</span></span><span style="display:flex;"><span>nombres.AddFirst(<span style="color:#e6db74">&#34;Luis&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> nombre <span style="color:#66d9ef">in</span> nombres)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Console.WriteLine(nombre);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Salida: Luis, Ana</span>
</span></span></code></pre></div><h4 id="pila-stack">Pila (Stack)<a hidden class="anchor" aria-hidden="true" href="#pila-stack">#</a></h4>
<p>Una pila es una estructura donde el último elemento en entrar es el primero en salir (Last In, First Out).</p>
<p>Se usa para manejar flujos reversibles, como en el caso de un historial de navegación.</p>
<p><strong>Ejemplo en C#</strong></p>
<p>Se agregan dos elementos a la pila por medio de <code>Push()</code>, mientras que <code>Pop()</code> elimina de la pila al último que entró y la guarda en la variable <code>actual</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Stack&lt;<span style="color:#66d9ef">string</span>&gt; historial = <span style="color:#66d9ef">new</span> Stack&lt;<span style="color:#66d9ef">string</span>&gt;();
</span></span><span style="display:flex;"><span>historial.Push(<span style="color:#e6db74">&#34;Página1&#34;</span>);
</span></span><span style="display:flex;"><span>historial.Push(<span style="color:#e6db74">&#34;Página2&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">string</span> actual = historial.Pop(); <span style="color:#75715e">// Página2</span>
</span></span><span style="display:flex;"><span>Console.WriteLine(actual);
</span></span></code></pre></div><h4 id="cola-queue">Cola (Queue)<a hidden class="anchor" aria-hidden="true" href="#cola-queue">#</a></h4>
<p>Una cola es una estructura donde el primer elemento en entrar es el primero en salir (First In, First Out).</p>
<p>Se usa cuando se necesitan procesar elementos en el orden en que llegaron, como en colas de impresión, tickets de atención a clientes, etc.</p>
<p><strong>Ejemplo en C#</strong></p>
<p>Se agregan dos tareas a la cola. Al hacer <code>Dequeue()</code>, se extrae la primera tarea ingresada (&ldquo;Tarea1&rdquo;), eliminándola de la cola, respetando el orden en el que llegaron.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Queue&lt;<span style="color:#66d9ef">string</span>&gt; tareas = <span style="color:#66d9ef">new</span> Queue&lt;<span style="color:#66d9ef">string</span>&gt;();
</span></span><span style="display:flex;"><span>tareas.Enqueue(<span style="color:#e6db74">&#34;Tarea1&#34;</span>);
</span></span><span style="display:flex;"><span>tareas.Enqueue(<span style="color:#e6db74">&#34;Tarea2&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">string</span> siguiente = tareas.Dequeue(); <span style="color:#75715e">// Tarea1</span>
</span></span><span style="display:flex;"><span>Console.WriteLine(siguiente);
</span></span></code></pre></div><h4 id="hash-tables-diccionarios-maps">Hash tables (Diccionarios, Maps)<a hidden class="anchor" aria-hidden="true" href="#hash-tables-diccionarios-maps">#</a></h4>
<p>Una tabla hash almacena datos en pares clave-valor. Internamente, usa una función hash que permite localizar rápidamente un valor a partir de su clave.</p>
<p>Se usa para buscar datos rápidamente mediante una clave única, como directorios, catálogos, etc.</p>
<p><strong>Ejemplo en C#</strong></p>
<p>Se crea un diccionario donde las claves son nombres y los valores son edades. Al pedir <code>edades[&quot;Ana&quot;]</code>, se accede directamente al valor 30 sin necesidad de recorrer toda la colección.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Dictionary&lt;<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">int</span>&gt; edades = <span style="color:#66d9ef">new</span> Dictionary&lt;<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">int</span>&gt;();
</span></span><span style="display:flex;"><span>edades[<span style="color:#e6db74">&#34;Juan&#34;</span>] = <span style="color:#ae81ff">25</span>;
</span></span><span style="display:flex;"><span>edades[<span style="color:#e6db74">&#34;Ana&#34;</span>] = <span style="color:#ae81ff">30</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Console.WriteLine(edades[<span style="color:#e6db74">&#34;Ana&#34;</span>]); <span style="color:#75715e">// 30</span>
</span></span></code></pre></div><h3 id="52-estructura-de-datos-no-lineales">5.2 Estructura de datos no lineales<a hidden class="anchor" aria-hidden="true" href="#52-estructura-de-datos-no-lineales">#</a></h3>
<p>Estas estructuras no siguen un orden secuencial, y permiten representar relaciones más complejas entre elementos.</p>
<h4 id="árbol-tree">Árbol (Tree)<a hidden class="anchor" aria-hidden="true" href="#árbol-tree">#</a></h4>
<p>Un árbol es una estructura jerárquica donde cada nodo puede tener múltiples hijos, pero solo un padre. Existen varios tipos.</p>
<p>Se usa en sistemas jerárquicos como menús, organización de archivos, árboles de decisiones, etc.</p>
<p><strong>Ejemplo en C#</strong></p>
<p>Se crea un árbol binario manualmente, con un nodo raíz que tiene dos hijos: uno a la izquierda con valor 5 y otro a la derecha con valor 15. Cada nodo puede expandirse.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Nodo</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Valor;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Nodo Izquierda;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Nodo Derecha;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Nodo raiz = <span style="color:#66d9ef">new</span> Nodo { Valor = <span style="color:#ae81ff">10</span> };
</span></span><span style="display:flex;"><span>raiz.Izquierda = <span style="color:#66d9ef">new</span> Nodo { Valor = <span style="color:#ae81ff">5</span> };
</span></span><span style="display:flex;"><span>raiz.Derecha = <span style="color:#66d9ef">new</span> Nodo { Valor = <span style="color:#ae81ff">15</span> };
</span></span></code></pre></div><h4 id="grafo">Grafo<a hidden class="anchor" aria-hidden="true" href="#grafo">#</a></h4>
<p>Un grafo es una estructura formada por nodos (vértices) y conexiones (aristas). Representa relaciones complejas entre elementos.</p>
<p>Se usa para representar mapas, relaciones entre entidades, etc.</p>
<p><strong>Ejemplo en C#</strong></p>
<p>Se construye un grafo no dirigido: el nodo &ldquo;A&rdquo; está conectado a &ldquo;B&rdquo; y &ldquo;C&rdquo;, y &ldquo;B&rdquo; también conecta con &ldquo;A&rdquo; y &ldquo;D&rdquo;. Se usa un diccionario donde cada nodo tiene una lista de vecinos.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Dictionary&lt;<span style="color:#66d9ef">string</span>, List&lt;<span style="color:#66d9ef">string</span>&gt;&gt; grafo = <span style="color:#66d9ef">new</span> Dictionary&lt;<span style="color:#66d9ef">string</span>, List&lt;<span style="color:#66d9ef">string</span>&gt;&gt;();
</span></span><span style="display:flex;"><span>grafo[<span style="color:#e6db74">&#34;A&#34;</span>] = <span style="color:#66d9ef">new</span> List&lt;<span style="color:#66d9ef">string</span>&gt; { <span style="color:#e6db74">&#34;B&#34;</span>, <span style="color:#e6db74">&#34;C&#34;</span> };
</span></span><span style="display:flex;"><span>grafo[<span style="color:#e6db74">&#34;B&#34;</span>] = <span style="color:#66d9ef">new</span> List&lt;<span style="color:#66d9ef">string</span>&gt; { <span style="color:#e6db74">&#34;A&#34;</span>, <span style="color:#e6db74">&#34;D&#34;</span> };
</span></span></code></pre></div><h2 id="vi-manejo-de-datos-en-poo">VI. Manejo de datos en POO<a hidden class="anchor" aria-hidden="true" href="#vi-manejo-de-datos-en-poo">#</a></h2>
<p>Es común que los objetos contengan información importante que debe conservarse incluso después de que el programa finaliza. Para lograr esto se aplican técnicas como la serialización, que permiten guardar y recuperar el estado de los objetos desde archivos. Esto hace posible mantener configuraciones o datos entre ejecuciones, así como permitir que la información se comparta fácilmente entre distintos sistemas o plataformas.</p>
<h3 id="persistencia">Persistencia<a hidden class="anchor" aria-hidden="true" href="#persistencia">#</a></h3>
<p>En POO, la persistencia se refiere a guardar el estado de un objeto para luego reconstruirlo cuando se necesite. Es decir, permite que los datos de un programa no se pierdan cuando el programa finaliza.</p>
<h3 id="serialización-binaria-poo">Serialización Binaria (POO)<a hidden class="anchor" aria-hidden="true" href="#serialización-binaria-poo">#</a></h3>
<p>La serialización binaria convierte un objeto en una secuencia de bytes, que puede almacenarse en un archivo o enviarse a través de la red. Posteriormente, puede recuperarse mediante deserialización, restaurando el estado exacto del objeto.</p>
<p>Solo puede ser interpretado por sistemas que conozcan su estructura interna, ya que no está en un formato legible.</p>
<h3 id="serialización-con-xml-programación-estructurada">Serialización con XML (Programación estructurada)<a hidden class="anchor" aria-hidden="true" href="#serialización-con-xml-programación-estructurada">#</a></h3>
<p>La serialización XML convierte un objeto en texto legible, utilizando etiquetas <code>&lt;xml&gt;</code>. Es una forma estructurada y estandarizada, útil para la portabilidad con otros sistemas o lenguajes.</p>
<p>La desventaja es que cualquiera puede abrir el archivo y modificarlo, por lo que tiene menor seguridad por default.</p>
<h4 id="serialización-normal-con-xml">Serialización normal con XML<a hidden class="anchor" aria-hidden="true" href="#serialización-normal-con-xml">#</a></h4>
<p>Este tipo de serialización toma un objeto único y lo transforma en un archivo XML plano. Solo se guarda el estado de una instancia y no incluye relaciones con otros objetos.</p>
<h4 id="serialización-por-composición-con-xml">Serialización por composición con XML<a hidden class="anchor" aria-hidden="true" href="#serialización-por-composición-con-xml">#</a></h4>
<p>Este enfoque permite serializar un objeto compuesto por otros objetos, reflejando sus relaciones en POO.</p>
<h3 id="deserialización">Deserialización<a hidden class="anchor" aria-hidden="true" href="#deserialización">#</a></h3>
<p>La deserialización es el proceso inverso: convertir los datos almacenados (binarios o XML) de nuevo en objetos en memoria. Esto permite recuperar el estado original del objeto y seguir trabajando con él en el programa.</p>
<h2 id="vii-patrones-de-diseño-en-poo">VII. Patrones de diseño en POO<a hidden class="anchor" aria-hidden="true" href="#vii-patrones-de-diseño-en-poo">#</a></h2>
<p>Un patrón de diseño es una solución reutilizable, comprobada y estructurada a un problema común que aparece constantemente al diseñar sistemas orientados a objetos.</p>
<p>Básicamente, son guías o plantillas que ayudan a resolver un problema específico de diseño.</p>
<p><strong>Sus elementos son</strong></p>
<ul>
<li><strong>Nombre</strong>: Forma de referirse al patrón de diseño.</li>
<li><strong>Problema</strong>: Explica cuándo debe usarse el patrón.</li>
<li><strong>La solución</strong>: Describe la estructura general, las clases involucradas, las relaciones entre ellas y cómo colaboran para resolver el problema.</li>
<li><strong>Las consecuencias</strong>: Analiza el impacto del patrón, tomando en cuenta el costo/beneficio, espacio/tiempo, lenguaje, impacto en flexibilidad, extensión y portabilidad.</li>
</ul>
<p>Los patrones de diseño se agrupan en tres categorías, según el tipo de problema que ayudan a resolver.</p>
<h3 id="71-patrones-de-creación">7.1 Patrones de creación<a hidden class="anchor" aria-hidden="true" href="#71-patrones-de-creación">#</a></h3>
<p>Se enfocan en cómo se crean los objetos. Permiten crear instancias de forma flexible.</p>
<ul>
<li><strong>Fábrica abstracta</strong>: Permite crear objetos relacionados sin especificar sus clases concretas.</li>
<li><strong>Método fábrica</strong>: Delega la creación de objetos a una subclase.</li>
<li><strong>Prototipo</strong>: Clona objetos a partir de una instancia de prototipo existente.</li>
<li><strong>Singleton</strong>: Asegura que solo exista una instancia de una clase y provee un punto de acceso global.</li>
</ul>
<h3 id="72-patrones-de-estructura">7.2 Patrones de estructura<a hidden class="anchor" aria-hidden="true" href="#72-patrones-de-estructura">#</a></h3>
<p>Ayudan a organizar las clases u objetos en estructuras más grandes sin perder flexibilidad. Mejoran la reutilización de componentes.</p>
<ul>
<li><strong>Adaptador</strong>: Convierte la interfaz de una clase en otra esperada por el cliente.</li>
<li><strong>Puente</strong>: Separa una abstracción de su implementación para que ambas puedan variar.</li>
<li><strong>Decorador</strong>: Añade funcionalidades a un objeto de forma dinámica sin modificar su clase.</li>
<li><strong>Fachada</strong>: Proporciona una interfaz simplificada a un conjunto complejo de clases.</li>
<li><strong>Proxy</strong>: Controla el acceso a un objeto, actuando como intermediario.</li>
</ul>
<h3 id="73-patrones-de-comportamiento">7.3 Patrones de comportamiento<a hidden class="anchor" aria-hidden="true" href="#73-patrones-de-comportamiento">#</a></h3>
<p>Ayudan a definir la comunicación entre objetos en el sistema y cómo es controlado el flujo.</p>
<ul>
<li><strong>Comando</strong>: Encapsula una solicitud como un objeto, permitiendo parametrizar y deshacer operaciones.</li>
<li><strong>Interprete</strong>: Define una gramática y un intérprete para entender y procesar expresiones.</li>
<li><strong>Iterador</strong>: Permite recorrer una colección sin exponer su implementación interna.</li>
<li><strong>Observador</strong>: Notifica automáticamente a múltiples objetos cuando el estado de otro cambia.</li>
<li><strong>Estrategia</strong>: Permite definir una familia de algoritmos y seleccionarlos dinámicamente.</li>
</ul>
<h3 id="74-anti-patrones">7.4 Anti-patrones<a hidden class="anchor" aria-hidden="true" href="#74-anti-patrones">#</a></h3>
<p>Los anti-patrones representan malas soluciones que se aplican comúnmente a problemas de diseño, pero que resultan en malos resultados.</p>
<ul>
<li>Muestran prácticas que parecen buenas al inicio, pero fallan a largo plazo.</li>
<li>También incluyen recomendaciones sobre cómo salir de una mala implementación hacia una solución más adecuada.</li>
</ul>
<h2 id="viii-poo-y-la-programación-orientada-a-eventos">VIII. POO y la programación orientada a eventos<a hidden class="anchor" aria-hidden="true" href="#viii-poo-y-la-programación-orientada-a-eventos">#</a></h2>
<p>La Programación Orientada a Eventos (POE) es un paradigma que se basa en la interacción con eventos, es decir, acciones que ocurren en el sistema, como hacer clic en un botón, mover el mouse, o recibir una notificación externa.</p>
<p>Cuando se combina con la Programación Orientada a Objetos (POO), permite crear aplicaciones interactivas donde los objetos pueden reaccionar a eventos. Este enfoque es común en interfaces gráficas de usuario y en sistemas donde las acciones del usuario determinan el flujo del programa como videojuegos.</p>
<h3 id="81-interfaces-gráficas-y-eventos">8.1 Interfaces gráficas y eventos<a hidden class="anchor" aria-hidden="true" href="#81-interfaces-gráficas-y-eventos">#</a></h3>
<p>En las interfaces gráficas, los eventos son disparados por acciones del usuario (clicks, teclas, movimientos), y se puede programar la reacción del sistema usando manejadores de eventos.</p>
<h4 id="eventos">Eventos<a hidden class="anchor" aria-hidden="true" href="#eventos">#</a></h4>
<p>Un evento es un mecanismo que permite que un objeto notifique a otros objetos cuando algo relevante ocurre.</p>
<p>En C#, los eventos se basan en delegados. Un evento necesita:</p>
<ul>
<li><strong>Un delegado</strong> que define la firma del método que responderá al evento.</li>
<li><strong>Un evento</strong> declarado con la palabra clave event.</li>
<li><strong>Uno o varios manejadores (handlers)</strong> que se suscriben al evento.</li>
</ul>
<h4 id="delegados">Delegados<a hidden class="anchor" aria-hidden="true" href="#delegados">#</a></h4>
<p>Un delegado es una especie de puntero a función, que define qué tipo de métodos se pueden invocar a través del evento.</p>
<h4 id="handlers">Handlers<a hidden class="anchor" aria-hidden="true" href="#handlers">#</a></h4>
<p>Un handler es un método que responde a un evento. Se suscribe a un evento y se ejecuta automáticamente cuando ese evento ocurre.</p>
<h4 id="sinks">Sinks<a hidden class="anchor" aria-hidden="true" href="#sinks">#</a></h4>
<p>Un sink es un término técnico usado para referirse al objeto que recibe el evento. Es decir, es el receptor del evento. También se puede considerar sink a la clase que contiene los handlers suscritos al evento.</p>
<h3 id="82-excepciones-y-manejo-de-errores">8.2 Excepciones y manejo de errores<a hidden class="anchor" aria-hidden="true" href="#82-excepciones-y-manejo-de-errores">#</a></h3>
<p>Las excepciones son eventos inesperados que ocurren durante la ejecución de un programa y pueden interrumpir su funcionamiento normal. Para evitar que el programa falle, se utiliza un mecanismo de <em>manejo de excepciones</em>.</p>
<p>El manejo de excepciones se realiza con los bloques <code>try...catch</code>, que permiten identificar y manejar errores de manera controlada, y se utilizan  cuando no se puede evitar el error con una validación como es el caso al leer un archivo, tener falta de memoria, acceder a una base de datos o convertir datos de entrada del usuario, etc.</p>
<p>Es recomendable colocar una excepción en secciones del código que identifiquemos como riesgosas como en zonas de apertura de archivos o comunicación red.</p>
<p><strong>Ejemplo en C#</strong></p>
<p>Se maneja una división por cero para evitar que el programa se detenga.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>	    <span style="color:#75715e">// Código que podría generar una excepción</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>		    <span style="color:#66d9ef">int</span> numero = <span style="color:#66d9ef">int</span>.Parse(Console.ReadLine()); <span style="color:#75715e">// Puede fallar si el usuario ingresa texto</span>
</span></span><span style="display:flex;"><span>		    Console.WriteLine(<span style="color:#e6db74">&#34;Número ingresado: &#34;</span> + numero);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Código para manejar la excepción</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">catch</span> (FormatException)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>		    Console.WriteLine(<span style="color:#e6db74">&#34;Error: Entrada no válida.&#34;</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="-más-información">/ Más Información<a hidden class="anchor" aria-hidden="true" href="#-más-información">#</a></h2>
<p><strong>Anterior</strong>: <a href="/apuntes/conceptos-generales-de-programaci%C3%B3n/">Conceptos Generales de Programación</a></p>
<h3 id="lenguajes-de-programación">Lenguajes de programación<a hidden class="anchor" aria-hidden="true" href="#lenguajes-de-programación">#</a></h3>
<ul>
<li><code>[[C Sharp]]</code></li>
<li><code>[[Java]]</code></li>
<li><code>[[JavaScript]]</code></li>
<li><code>[[Python]]</code></li>
</ul>
<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/programacion/">Programacion</a></li>
      <li><a href="http://localhost:1313/tags/enciclopedia/">Enciclopedia</a></li>
      <li><a href="http://localhost:1313/tags/post/">Post</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">oscarzt20</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
